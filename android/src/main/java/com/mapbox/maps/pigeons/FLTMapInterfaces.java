// Autogenerated from Pigeon (v11.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

package com.mapbox.maps.pigeons;

import android.util.Log;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import io.flutter.plugin.common.BasicMessageChannel;
import io.flutter.plugin.common.BinaryMessenger;
import io.flutter.plugin.common.MessageCodec;
import io.flutter.plugin.common.StandardMessageCodec;
import java.io.ByteArrayOutputStream;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/** Generated class from Pigeon. */
@SuppressWarnings({"unused", "unchecked", "CodeBlock2Expr", "RedundantSuppression", "serial"})
public class FLTMapInterfaces {

  /** Error class for passing custom error details to Flutter via a thrown PlatformException. */
  public static class FlutterError extends RuntimeException {

    /** The error code. */
    public final String code;

    /** The error details. Must be a datatype supported by the api codec. */
    public final Object details;

    public FlutterError(@NonNull String code, @Nullable String message, @Nullable Object details) 
    {
      super(message);
      this.code = code;
      this.details = details;
    }
  }

  @NonNull
  protected static ArrayList<Object> wrapError(@NonNull Throwable exception) {
    ArrayList<Object> errorList = new ArrayList<Object>(3);
    if (exception instanceof FlutterError) {
      FlutterError error = (FlutterError) exception;
      errorList.add(error.code);
      errorList.add(error.getMessage());
      errorList.add(error.details);
    } else {
      errorList.add(exception.toString());
      errorList.add(exception.getClass().getSimpleName());
      errorList.add(
        "Cause: " + exception.getCause() + ", Stacktrace: " + Log.getStackTraceString(exception));
    }
    return errorList;
  }

  /** Describes glyphs rasterization modes. */
  public enum GlyphsRasterizationMode {
    /** No glyphs are rasterized locally. All glyphs are loaded from the server. */
    NO_GLYPHS_RASTERIZED_LOCALLY(0),
    /** Ideographs are rasterized locally, and they are not loaded from the server. */
    IDEOGRAPHS_RASTERIZED_LOCALLY(1),
    /** All glyphs are rasterized locally. No glyphs are loaded from the server. */
    ALL_GLYPHS_RASTERIZED_LOCALLY(2);

    final int index;

    private GlyphsRasterizationMode(final int index) {
      this.index = index;
    }
  }

  /**
   * Describes the map context mode.
   * We can make some optimizations if we know that the drawing context is not shared with other code.
   */
  public enum ContextMode {
    /**
     * Unique context mode: in OpenGL, the GL context is not shared, thus we can retain knowledge about the GL state
     * from a previous render pass. It also enables clearing the screen using glClear for the bottommost background
     * layer when no pattern is applied to that layer.
     */
    UNIQUE(0),
    /**
     * Shared context mode: in OpenGL, the GL context is shared with other renderers, thus we cannot rely on the GL
     * state set from a previous render pass.
     */
    SHARED(1);

    final int index;

    private ContextMode(final int index) {
      this.index = index;
    }
  }

  /** Describes whether to constrain the map in both axes or only vertically e.g. while panning. */
  public enum ConstrainMode {
    /** No constrains. */
    NONE(0),
    /** Constrain to height only */
    HEIGHT_ONLY(1),
    /** Constrain both width and height axes. */
    WIDTH_AND_HEIGHT(2);

    final int index;

    private ConstrainMode(final int index) {
      this.index = index;
    }
  }

  /** Satisfies embedding platforms that requires the viewport coordinate systems to be set according to its standards. */
  public enum ViewportMode {
    /** Default viewport */
    DEFAULT(0),
    /** Viewport flipped on the y-axis. */
    FLIPPED_Y(1);

    final int index;

    private ViewportMode(final int index) {
      this.index = index;
    }
  }

  /** Describes the map orientation. */
  public enum NorthOrientation {
    /** Default, map oriented upwards */
    UPWARDS(0),
    /** Map oriented righwards */
    RIGHTWARDS(1),
    /** Map oriented downwards */
    DOWNWARDS(2),
    /** Map oriented leftwards */
    LEFTWARDS(3);

    final int index;

    private NorthOrientation(final int index) {
      this.index = index;
    }
  }

  /** Options for enabling debugging features in a map. */
  public enum MapDebugOptionsData {
    /**
     * Edges of tile boundaries are shown as thick, red lines to help diagnose
     * tile clipping issues.
     */
    TILE_BORDERS(0),
    /** Each tile shows its tile coordinate (x/y/z) in the upper-left corner. */
    PARSE_STATUS(1),
    /** Each tile shows a timestamp indicating when it was loaded. */
    TIMESTAMPS(2),
    /**
     * Edges of glyphs and symbols are shown as faint, green lines to help
     * diagnose collision and label placement issues.
     */
    COLLISION(3),
    /**
     * Each drawing operation is replaced by a translucent fill. Overlapping
     * drawing operations appear more prominent to help diagnose overdrawing.
     */
    OVERDRAW(4),
    /** The stencil buffer is shown instead of the color buffer. */
    STENCIL_CLIP(5),
    /** The depth buffer is shown instead of the color buffer. */
    DEPTH_BUFFER(6),
    /**
     * Visualize residency of tiles in the render cache. Tile boundaries of cached tiles
     * are rendered with green, tiles waiting for an update with yellow and tiles not in the cache
     * with red.
     */
    RENDER_CACHE(7),
    /** Show 3D model bounding boxes. */
    MODEL_BOUNDS(8),
    /** Show a wireframe for terrain. */
    TERRAIN_WIREFRAME(9);

    final int index;

    private MapDebugOptionsData(final int index) {
      this.index = index;
    }
  }

  /** Enum describing how to place view annotation relatively to geometry. */
  public enum ViewAnnotationAnchor {
    /** The top of the view annotation is placed closest to the geometry. */
    TOP(0),
    /** The left side of the view annotation is placed closest to the geometry. */
    LEFT(1),
    /** The bottom of the view annotation is placed closest to the geometry. */
    BOTTOM(2),
    /** The right side of the view annotation is placed closest to the geometry. */
    RIGHT(3),
    /** The top-left corner of the view annotation is placed closest to the geometry. */
    TOP_LEFT(4),
    /** The bottom-right corner of the view annotation is placed closest to the geometry. */
    BOTTOM_RIGHT(5),
    /** The top-right corner of the view annotation is placed closest to the geometry. */
    TOP_RIGHT(6),
    /** The bottom-left corner of the view annotation is placed closest to the geometry. */
    BOTTOM_LEFT(7),
    /** The center of the view annotation is placed closest to the geometry. */
    CENTER(8);

    final int index;

    private ViewAnnotationAnchor(final int index) {
      this.index = index;
    }
  }

  /** Type information of the variant's content */
  public enum Type {
    SCREEN_BOX(0),
    SCREEN_COORDINATE(1),
    LIST(2);

    final int index;

    private Type(final int index) {
      this.index = index;
    }
  }

  /** Describes the reason for a style package download request failure. */
  public enum StylePackErrorType {
    /** The operation was canceled. */
    CANCELED(0),
    /** The style package does not exist. */
    DOES_NOT_EXIST(1),
    /** There is no available space to store the resources. */
    DISK_FULL(2),
    /** Other reason. */
    OTHER(3);

    final int index;

    private StylePackErrorType(final int index) {
      this.index = index;
    }
  }

  /** Describes the reason for an offline request response error. */
  public enum ResponseErrorReason {
    /** The resource is not found. */
    NOT_FOUND(0),
    /** The server error. */
    SERVER(1),
    /** The connection error. */
    CONNECTION(2),
    /** The error happened because of a rate limit. */
    RATE_LIMIT(3),
    /** Other reason. */
    OTHER(4);

    final int index;

    private ResponseErrorReason(final int index) {
      this.index = index;
    }
  }

  /** Describes the download state of a region. */
  public enum OfflineRegionDownloadState {
    /** Indicates downloading is inactive. */
    INACTIVE(0),
    /** Indicates downloading is active. */
    ACTIVE(1);

    final int index;

    private OfflineRegionDownloadState(final int index) {
      this.index = index;
    }
  }

  /** Describes tile store usage modes. */
  public enum TileStoreUsageMode {
    /**
     * Tile store usage is disabled.
     *
     * The implementation skips checking tile store when requesting a tile.
     */
    DISABLED(0),
    /**
     * Tile store enabled for accessing loaded tile packs.
     *
     * The implementation first checks tile store when requesting a tile.
     * If a tile pack is already loaded, the tile will be extracted and returned. Otherwise, the implementation
     * falls back to requesting the individual tile and storing it in the disk cache.
     */
    READ_ONLY(1),
    /**
     * Tile store enabled for accessing local tile packs and for loading new tile packs from server.
     *
     * All tile requests are converted to tile pack requests, i.e.
     * the tile pack that includes the request tile will be loaded, and the tile extracted
     * from it. In this mode, no individual tile requests will be made.
     *
     * This mode can be useful if the map trajectory is predefined and the user cannot pan
     * freely (e.g. navigation use cases), so that there is a good chance tile packs are already loaded
     * in the vicinity of the user.
     *
     * If users can pan freely, this mode is not recommended. Otherwise, panning
     * will download tile packs instead of using individual tiles. Note that this means that we could first
     * download an individual tile, and then a tile pack that also includes this tile. The individual tile in
     * the disk cache won’t be used as long as the up-to-date tile pack exists in the cache.
     */
    READ_AND_UPDATE(2);

    final int index;

    private TileStoreUsageMode(final int index) {
      this.index = index;
    }
  }

  /** Describes the kind of a style property value. */
  public enum StylePropertyValueKind {
    /** The property value is not defined. */
    UNDEFINED(0),
    /** The property value is a constant. */
    CONSTANT(1),
    /** The property value is a style [expression](https://docs.mapbox.com/mapbox-gl-js/style-spec/#expressions). */
    EXPRESSION(2),
    /** Property value is a style [transition](https://docs.mapbox.com/mapbox-gl-js/style-spec/#transition). */
    TRANSITION(3);

    final int index;

    private StylePropertyValueKind(final int index) {
      this.index = index;
    }
  }

  /** HTTP defines a set of request methods to indicate the desired action to be performed for a given resource. */
  public enum HttpMethod {
    /** The GET method requests a representation of the specified resource. Requests using GET should only retrieve data. */
    GET(0),
    /** The HEAD method asks for a response identical to that of a GET request, but without the response body. */
    HEAD(1),
    /** The POST method sends data (stored in the request body) to a server to create or update a given resource. */
    POST(2);

    final int index;

    private HttpMethod(final int index) {
      this.index = index;
    }
  }

  /** Classify network types based on cost. */
  public enum NetworkRestriction {
    /** Allow access to all network types. */
    NONE(0),
    /** Forbid network access to expensive networks, such as cellular. */
    DISALLOW_EXPENSIVE(1),
    /** Forbid access to all network types. */
    DISALLOW_ALL(2);

    final int index;

    private NetworkRestriction(final int index) {
      this.index = index;
    }
  }

  /** Enum which describes possible error types which could happen during HTTP request/download calls. */
  public enum HttpRequestErrorType {
    /** Establishing connection related error. */
    CONNECTION_ERROR(0),
    /** SSL related error. */
    SSLERROR(1),
    /** Request was cancelled by the user. */
    REQUEST_CANCELLED(2),
    /** Timeout error. */
    REQUEST_TIMED_OUT(3),
    /** Range request failed. */
    RANGE_ERROR(4),
    /** Other than above error. */
    OTHER_ERROR(5);

    final int index;

    private HttpRequestErrorType(final int index) {
      this.index = index;
    }
  }

  /** Enum which represents different error cases which could happen during download session. */
  public enum DownloadErrorCode {
    /** General filesystem related error code. For cases like: write error, no such file or directory, not enough space and etc. */
    FILE_SYSTEM_ERROR(0),
    /** General network related error. Should be probably representation of HttpRequestError. */
    NETWORK_ERROR(1);

    final int index;

    private DownloadErrorCode(final int index) {
      this.index = index;
    }
  }

  /** Enum representing state of download session. */
  public enum DownloadState {
    /** Download session initiated but not started yet. */
    PENDING(0),
    /** Download session is in progress. */
    DOWNLOADING(1),
    /** Download session failed. */
    FAILED(2),
    /** Download session successfully finished. */
    FINISHED(3);

    final int index;

    private DownloadState(final int index) {
      this.index = index;
    }
  }

  /** Describes the tiles data domain. */
  public enum TileDataDomain {
    /** Data for Maps. */
    MAPS(0),
    /** Data for Navigation. */
    NAVIGATION(1),
    /** Data for Search. */
    SEARCH(2),
    /** Data for ADAS */
    ADAS(3);

    final int index;

    private TileDataDomain(final int index) {
      this.index = index;
    }
  }

  /** Describes the reason for a tile region download request failure. */
  public enum TileRegionErrorType {
    /** The operation was canceled. */
    CANCELED(0),
    /** tile region does not exist. */
    DOES_NOT_EXIST(1),
    /** Tileset descriptors resolving failed. */
    TILESET_DESCRIPTOR(2),
    /** There is no available space to store the resources */
    DISK_FULL(3),
    /** Other reason. */
    OTHER(4),
    /** The region contains more tiles than allowed. */
    TILE_COUNT_EXCEEDED(5);

    final int index;

    private TileRegionErrorType(final int index) {
      this.index = index;
    }
  }

  /**
   * The distance on each side between rectangles, when one is contained into other.
   *
   * All fields' values are in `platform pixel` units.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class MbxEdgeInsets {
    /** Padding from the top. */
    private @NonNull Double top;

    public @NonNull Double getTop() {
      return top;
    }

    public void setTop(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"top\" is null.");
      }
      this.top = setterArg;
    }

    /** Padding from the left. */
    private @NonNull Double left;

    public @NonNull Double getLeft() {
      return left;
    }

    public void setLeft(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"left\" is null.");
      }
      this.left = setterArg;
    }

    /** Padding from the bottom. */
    private @NonNull Double bottom;

    public @NonNull Double getBottom() {
      return bottom;
    }

    public void setBottom(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"bottom\" is null.");
      }
      this.bottom = setterArg;
    }

    /** Padding from the right. */
    private @NonNull Double right;

    public @NonNull Double getRight() {
      return right;
    }

    public void setRight(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"right\" is null.");
      }
      this.right = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    MbxEdgeInsets() {}

    public static final class Builder {

      private @Nullable Double top;

      public @NonNull Builder setTop(@NonNull Double setterArg) {
        this.top = setterArg;
        return this;
      }

      private @Nullable Double left;

      public @NonNull Builder setLeft(@NonNull Double setterArg) {
        this.left = setterArg;
        return this;
      }

      private @Nullable Double bottom;

      public @NonNull Builder setBottom(@NonNull Double setterArg) {
        this.bottom = setterArg;
        return this;
      }

      private @Nullable Double right;

      public @NonNull Builder setRight(@NonNull Double setterArg) {
        this.right = setterArg;
        return this;
      }

      public @NonNull MbxEdgeInsets build() {
        MbxEdgeInsets pigeonReturn = new MbxEdgeInsets();
        pigeonReturn.setTop(top);
        pigeonReturn.setLeft(left);
        pigeonReturn.setBottom(bottom);
        pigeonReturn.setRight(right);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(4);
      toListResult.add(top);
      toListResult.add(left);
      toListResult.add(bottom);
      toListResult.add(right);
      return toListResult;
    }

    static @NonNull MbxEdgeInsets fromList(@NonNull ArrayList<Object> list) {
      MbxEdgeInsets pigeonResult = new MbxEdgeInsets();
      Object top = list.get(0);
      pigeonResult.setTop((Double) top);
      Object left = list.get(1);
      pigeonResult.setLeft((Double) left);
      Object bottom = list.get(2);
      pigeonResult.setBottom((Double) bottom);
      Object right = list.get(3);
      pigeonResult.setRight((Double) right);
      return pigeonResult;
    }
  }

  /**
   * Various options for describing the viewpoint of a camera. All fields are
   * optional.
   *
   * Anchor and center points are mutually exclusive, with preference for the
   * center point when both are set.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class CameraOptions {
    /** Coordinate at the center of the camera. */
    private @Nullable Map<String, Object> center;

    public @Nullable Map<String, Object> getCenter() {
      return center;
    }

    public void setCenter(@Nullable Map<String, Object> setterArg) {
      this.center = setterArg;
    }

    /**
     * Padding around the interior of the view that affects the frame of
     * reference for `center`.
     */
    private @Nullable MbxEdgeInsets padding;

    public @Nullable MbxEdgeInsets getPadding() {
      return padding;
    }

    public void setPadding(@Nullable MbxEdgeInsets setterArg) {
      this.padding = setterArg;
    }

    /**
     * Point of reference for `zoom` and `angle`, assuming an origin at the
     * top-left corner of the view.
     */
    private @Nullable ScreenCoordinate anchor;

    public @Nullable ScreenCoordinate getAnchor() {
      return anchor;
    }

    public void setAnchor(@Nullable ScreenCoordinate setterArg) {
      this.anchor = setterArg;
    }

    /**
     * Zero-based zoom level. Constrained to the minimum and maximum zoom
     * levels.
     */
    private @Nullable Double zoom;

    public @Nullable Double getZoom() {
      return zoom;
    }

    public void setZoom(@Nullable Double setterArg) {
      this.zoom = setterArg;
    }

    /** Bearing, measured in degrees from true north. Wrapped to [0, 360). */
    private @Nullable Double bearing;

    public @Nullable Double getBearing() {
      return bearing;
    }

    public void setBearing(@Nullable Double setterArg) {
      this.bearing = setterArg;
    }

    /** Pitch toward the horizon measured in degrees. */
    private @Nullable Double pitch;

    public @Nullable Double getPitch() {
      return pitch;
    }

    public void setPitch(@Nullable Double setterArg) {
      this.pitch = setterArg;
    }

    public static final class Builder {

      private @Nullable Map<String, Object> center;

      public @NonNull Builder setCenter(@Nullable Map<String, Object> setterArg) {
        this.center = setterArg;
        return this;
      }

      private @Nullable MbxEdgeInsets padding;

      public @NonNull Builder setPadding(@Nullable MbxEdgeInsets setterArg) {
        this.padding = setterArg;
        return this;
      }

      private @Nullable ScreenCoordinate anchor;

      public @NonNull Builder setAnchor(@Nullable ScreenCoordinate setterArg) {
        this.anchor = setterArg;
        return this;
      }

      private @Nullable Double zoom;

      public @NonNull Builder setZoom(@Nullable Double setterArg) {
        this.zoom = setterArg;
        return this;
      }

      private @Nullable Double bearing;

      public @NonNull Builder setBearing(@Nullable Double setterArg) {
        this.bearing = setterArg;
        return this;
      }

      private @Nullable Double pitch;

      public @NonNull Builder setPitch(@Nullable Double setterArg) {
        this.pitch = setterArg;
        return this;
      }

      public @NonNull CameraOptions build() {
        CameraOptions pigeonReturn = new CameraOptions();
        pigeonReturn.setCenter(center);
        pigeonReturn.setPadding(padding);
        pigeonReturn.setAnchor(anchor);
        pigeonReturn.setZoom(zoom);
        pigeonReturn.setBearing(bearing);
        pigeonReturn.setPitch(pitch);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(6);
      toListResult.add(center);
      toListResult.add((padding == null) ? null : padding.toList());
      toListResult.add((anchor == null) ? null : anchor.toList());
      toListResult.add(zoom);
      toListResult.add(bearing);
      toListResult.add(pitch);
      return toListResult;
    }

    static @NonNull CameraOptions fromList(@NonNull ArrayList<Object> list) {
      CameraOptions pigeonResult = new CameraOptions();
      Object center = list.get(0);
      pigeonResult.setCenter((Map<String, Object>) center);
      Object padding = list.get(1);
      pigeonResult.setPadding((padding == null) ? null : MbxEdgeInsets.fromList((ArrayList<Object>) padding));
      Object anchor = list.get(2);
      pigeonResult.setAnchor((anchor == null) ? null : ScreenCoordinate.fromList((ArrayList<Object>) anchor));
      Object zoom = list.get(3);
      pigeonResult.setZoom((Double) zoom);
      Object bearing = list.get(4);
      pigeonResult.setBearing((Double) bearing);
      Object pitch = list.get(5);
      pigeonResult.setPitch((Double) pitch);
      return pigeonResult;
    }
  }

  /**
   * Describes the viewpoint of a camera.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class CameraState {
    /** Coordinate at the center of the camera. */
    private @NonNull Map<String, Object> center;

    public @NonNull Map<String, Object> getCenter() {
      return center;
    }

    public void setCenter(@NonNull Map<String, Object> setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"center\" is null.");
      }
      this.center = setterArg;
    }

    /**
     * Padding around the interior of the view that affects the frame of
     * reference for `center`.
     */
    private @NonNull MbxEdgeInsets padding;

    public @NonNull MbxEdgeInsets getPadding() {
      return padding;
    }

    public void setPadding(@NonNull MbxEdgeInsets setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"padding\" is null.");
      }
      this.padding = setterArg;
    }

    /**
     * Zero-based zoom level. Constrained to the minimum and maximum zoom
     * levels.
     */
    private @NonNull Double zoom;

    public @NonNull Double getZoom() {
      return zoom;
    }

    public void setZoom(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"zoom\" is null.");
      }
      this.zoom = setterArg;
    }

    /** Bearing, measured in degrees from true north. Wrapped to [0, 360). */
    private @NonNull Double bearing;

    public @NonNull Double getBearing() {
      return bearing;
    }

    public void setBearing(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"bearing\" is null.");
      }
      this.bearing = setterArg;
    }

    /** Pitch toward the horizon measured in degrees. */
    private @NonNull Double pitch;

    public @NonNull Double getPitch() {
      return pitch;
    }

    public void setPitch(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"pitch\" is null.");
      }
      this.pitch = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    CameraState() {}

    public static final class Builder {

      private @Nullable Map<String, Object> center;

      public @NonNull Builder setCenter(@NonNull Map<String, Object> setterArg) {
        this.center = setterArg;
        return this;
      }

      private @Nullable MbxEdgeInsets padding;

      public @NonNull Builder setPadding(@NonNull MbxEdgeInsets setterArg) {
        this.padding = setterArg;
        return this;
      }

      private @Nullable Double zoom;

      public @NonNull Builder setZoom(@NonNull Double setterArg) {
        this.zoom = setterArg;
        return this;
      }

      private @Nullable Double bearing;

      public @NonNull Builder setBearing(@NonNull Double setterArg) {
        this.bearing = setterArg;
        return this;
      }

      private @Nullable Double pitch;

      public @NonNull Builder setPitch(@NonNull Double setterArg) {
        this.pitch = setterArg;
        return this;
      }

      public @NonNull CameraState build() {
        CameraState pigeonReturn = new CameraState();
        pigeonReturn.setCenter(center);
        pigeonReturn.setPadding(padding);
        pigeonReturn.setZoom(zoom);
        pigeonReturn.setBearing(bearing);
        pigeonReturn.setPitch(pitch);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(5);
      toListResult.add(center);
      toListResult.add((padding == null) ? null : padding.toList());
      toListResult.add(zoom);
      toListResult.add(bearing);
      toListResult.add(pitch);
      return toListResult;
    }

    static @NonNull CameraState fromList(@NonNull ArrayList<Object> list) {
      CameraState pigeonResult = new CameraState();
      Object center = list.get(0);
      pigeonResult.setCenter((Map<String, Object>) center);
      Object padding = list.get(1);
      pigeonResult.setPadding((padding == null) ? null : MbxEdgeInsets.fromList((ArrayList<Object>) padding));
      Object zoom = list.get(2);
      pigeonResult.setZoom((Double) zoom);
      Object bearing = list.get(3);
      pigeonResult.setBearing((Double) bearing);
      Object pitch = list.get(4);
      pigeonResult.setPitch((Double) pitch);
      return pigeonResult;
    }
  }

  /**
   * Holds options to be used for setting `camera bounds`.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class CameraBoundsOptions {
    /** The latitude and longitude bounds to which the camera center are constrained. */
    private @Nullable CoordinateBounds bounds;

    public @Nullable CoordinateBounds getBounds() {
      return bounds;
    }

    public void setBounds(@Nullable CoordinateBounds setterArg) {
      this.bounds = setterArg;
    }

    /** The maximum zoom level, in Mapbox zoom levels 0-25.5. At low zoom levels, a small set of map tiles covers a large geographical area. At higher zoom levels, a larger number of tiles cover a smaller geographical area. */
    private @Nullable Double maxZoom;

    public @Nullable Double getMaxZoom() {
      return maxZoom;
    }

    public void setMaxZoom(@Nullable Double setterArg) {
      this.maxZoom = setterArg;
    }

    /** The minimum zoom level, in Mapbox zoom levels 0-25.5. */
    private @Nullable Double minZoom;

    public @Nullable Double getMinZoom() {
      return minZoom;
    }

    public void setMinZoom(@Nullable Double setterArg) {
      this.minZoom = setterArg;
    }

    /** The maximum allowed pitch value in degrees. */
    private @Nullable Double maxPitch;

    public @Nullable Double getMaxPitch() {
      return maxPitch;
    }

    public void setMaxPitch(@Nullable Double setterArg) {
      this.maxPitch = setterArg;
    }

    /** The minimum allowed pitch value in degrees. */
    private @Nullable Double minPitch;

    public @Nullable Double getMinPitch() {
      return minPitch;
    }

    public void setMinPitch(@Nullable Double setterArg) {
      this.minPitch = setterArg;
    }

    public static final class Builder {

      private @Nullable CoordinateBounds bounds;

      public @NonNull Builder setBounds(@Nullable CoordinateBounds setterArg) {
        this.bounds = setterArg;
        return this;
      }

      private @Nullable Double maxZoom;

      public @NonNull Builder setMaxZoom(@Nullable Double setterArg) {
        this.maxZoom = setterArg;
        return this;
      }

      private @Nullable Double minZoom;

      public @NonNull Builder setMinZoom(@Nullable Double setterArg) {
        this.minZoom = setterArg;
        return this;
      }

      private @Nullable Double maxPitch;

      public @NonNull Builder setMaxPitch(@Nullable Double setterArg) {
        this.maxPitch = setterArg;
        return this;
      }

      private @Nullable Double minPitch;

      public @NonNull Builder setMinPitch(@Nullable Double setterArg) {
        this.minPitch = setterArg;
        return this;
      }

      public @NonNull CameraBoundsOptions build() {
        CameraBoundsOptions pigeonReturn = new CameraBoundsOptions();
        pigeonReturn.setBounds(bounds);
        pigeonReturn.setMaxZoom(maxZoom);
        pigeonReturn.setMinZoom(minZoom);
        pigeonReturn.setMaxPitch(maxPitch);
        pigeonReturn.setMinPitch(minPitch);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(5);
      toListResult.add((bounds == null) ? null : bounds.toList());
      toListResult.add(maxZoom);
      toListResult.add(minZoom);
      toListResult.add(maxPitch);
      toListResult.add(minPitch);
      return toListResult;
    }

    static @NonNull CameraBoundsOptions fromList(@NonNull ArrayList<Object> list) {
      CameraBoundsOptions pigeonResult = new CameraBoundsOptions();
      Object bounds = list.get(0);
      pigeonResult.setBounds((bounds == null) ? null : CoordinateBounds.fromList((ArrayList<Object>) bounds));
      Object maxZoom = list.get(1);
      pigeonResult.setMaxZoom((Double) maxZoom);
      Object minZoom = list.get(2);
      pigeonResult.setMinZoom((Double) minZoom);
      Object maxPitch = list.get(3);
      pigeonResult.setMaxPitch((Double) maxPitch);
      Object minPitch = list.get(4);
      pigeonResult.setMinPitch((Double) minPitch);
      return pigeonResult;
    }
  }

  /**
   * Holds information about `camera bounds`.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class CameraBounds {
    /** The latitude and longitude bounds to which the camera center are constrained. */
    private @NonNull CoordinateBounds bounds;

    public @NonNull CoordinateBounds getBounds() {
      return bounds;
    }

    public void setBounds(@NonNull CoordinateBounds setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"bounds\" is null.");
      }
      this.bounds = setterArg;
    }

    /** The maximum zoom level, in Mapbox zoom levels 0-25.5. At low zoom levels, a small set of map tiles covers a large geographical area. At higher zoom levels, a larger number of tiles cover a smaller geographical area. */
    private @NonNull Double maxZoom;

    public @NonNull Double getMaxZoom() {
      return maxZoom;
    }

    public void setMaxZoom(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"maxZoom\" is null.");
      }
      this.maxZoom = setterArg;
    }

    /** The minimum zoom level, in Mapbox zoom levels 0-25.5. */
    private @NonNull Double minZoom;

    public @NonNull Double getMinZoom() {
      return minZoom;
    }

    public void setMinZoom(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"minZoom\" is null.");
      }
      this.minZoom = setterArg;
    }

    /** The maximum allowed pitch value in degrees. */
    private @NonNull Double maxPitch;

    public @NonNull Double getMaxPitch() {
      return maxPitch;
    }

    public void setMaxPitch(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"maxPitch\" is null.");
      }
      this.maxPitch = setterArg;
    }

    /** The minimum allowed pitch value in degrees. */
    private @NonNull Double minPitch;

    public @NonNull Double getMinPitch() {
      return minPitch;
    }

    public void setMinPitch(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"minPitch\" is null.");
      }
      this.minPitch = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    CameraBounds() {}

    public static final class Builder {

      private @Nullable CoordinateBounds bounds;

      public @NonNull Builder setBounds(@NonNull CoordinateBounds setterArg) {
        this.bounds = setterArg;
        return this;
      }

      private @Nullable Double maxZoom;

      public @NonNull Builder setMaxZoom(@NonNull Double setterArg) {
        this.maxZoom = setterArg;
        return this;
      }

      private @Nullable Double minZoom;

      public @NonNull Builder setMinZoom(@NonNull Double setterArg) {
        this.minZoom = setterArg;
        return this;
      }

      private @Nullable Double maxPitch;

      public @NonNull Builder setMaxPitch(@NonNull Double setterArg) {
        this.maxPitch = setterArg;
        return this;
      }

      private @Nullable Double minPitch;

      public @NonNull Builder setMinPitch(@NonNull Double setterArg) {
        this.minPitch = setterArg;
        return this;
      }

      public @NonNull CameraBounds build() {
        CameraBounds pigeonReturn = new CameraBounds();
        pigeonReturn.setBounds(bounds);
        pigeonReturn.setMaxZoom(maxZoom);
        pigeonReturn.setMinZoom(minZoom);
        pigeonReturn.setMaxPitch(maxPitch);
        pigeonReturn.setMinPitch(minPitch);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(5);
      toListResult.add((bounds == null) ? null : bounds.toList());
      toListResult.add(maxZoom);
      toListResult.add(minZoom);
      toListResult.add(maxPitch);
      toListResult.add(minPitch);
      return toListResult;
    }

    static @NonNull CameraBounds fromList(@NonNull ArrayList<Object> list) {
      CameraBounds pigeonResult = new CameraBounds();
      Object bounds = list.get(0);
      pigeonResult.setBounds((bounds == null) ? null : CoordinateBounds.fromList((ArrayList<Object>) bounds));
      Object maxZoom = list.get(1);
      pigeonResult.setMaxZoom((Double) maxZoom);
      Object minZoom = list.get(2);
      pigeonResult.setMinZoom((Double) minZoom);
      Object maxPitch = list.get(3);
      pigeonResult.setMaxPitch((Double) maxPitch);
      Object minPitch = list.get(4);
      pigeonResult.setMinPitch((Double) minPitch);
      return pigeonResult;
    }
  }

  /** Generated class from Pigeon that represents data sent in messages. */
  public static final class MapAnimationOptions {
    /**
     * The duration of the animation in milliseconds.
     * If not set explicitly default duration will be taken 300ms
     */
    private @Nullable Long duration;

    public @Nullable Long getDuration() {
      return duration;
    }

    public void setDuration(@Nullable Long setterArg) {
      this.duration = setterArg;
    }

    /**
     * The amount of time, in milliseconds, to delay starting the animation after animation start.
     * If not set explicitly default startDelay will be taken 0ms. This only works for Android.
     */
    private @Nullable Long startDelay;

    public @Nullable Long getStartDelay() {
      return startDelay;
    }

    public void setStartDelay(@Nullable Long setterArg) {
      this.startDelay = setterArg;
    }

    public static final class Builder {

      private @Nullable Long duration;

      public @NonNull Builder setDuration(@Nullable Long setterArg) {
        this.duration = setterArg;
        return this;
      }

      private @Nullable Long startDelay;

      public @NonNull Builder setStartDelay(@Nullable Long setterArg) {
        this.startDelay = setterArg;
        return this;
      }

      public @NonNull MapAnimationOptions build() {
        MapAnimationOptions pigeonReturn = new MapAnimationOptions();
        pigeonReturn.setDuration(duration);
        pigeonReturn.setStartDelay(startDelay);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(duration);
      toListResult.add(startDelay);
      return toListResult;
    }

    static @NonNull MapAnimationOptions fromList(@NonNull ArrayList<Object> list) {
      MapAnimationOptions pigeonResult = new MapAnimationOptions();
      Object duration = list.get(0);
      pigeonResult.setDuration((duration == null) ? null : ((duration instanceof Integer) ? (Integer) duration : (Long) duration));
      Object startDelay = list.get(1);
      pigeonResult.setStartDelay((startDelay == null) ? null : ((startDelay instanceof Integer) ? (Integer) startDelay : (Long) startDelay));
      return pigeonResult;
    }
  }

  /**
   * A rectangular area as measured on a two-dimensional map projection.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class CoordinateBounds {
    /**
     * Coordinate at the southwest corner.
     * Note: setting this field with invalid values (infinite, NaN) will crash the application.
     */
    private @NonNull Map<String, Object> southwest;

    public @NonNull Map<String, Object> getSouthwest() {
      return southwest;
    }

    public void setSouthwest(@NonNull Map<String, Object> setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"southwest\" is null.");
      }
      this.southwest = setterArg;
    }

    /**
     * Coordinate at the northeast corner.
     * Note: setting this field with invalid values (infinite, NaN) will crash the application.
     */
    private @NonNull Map<String, Object> northeast;

    public @NonNull Map<String, Object> getNortheast() {
      return northeast;
    }

    public void setNortheast(@NonNull Map<String, Object> setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"northeast\" is null.");
      }
      this.northeast = setterArg;
    }

    /**
     * If set to `true`, an infinite (unconstrained) bounds covering the world coordinates would be used.
     * Coordinates provided in `southwest` and `northeast` fields would be omitted and have no effect.
     */
    private @NonNull Boolean infiniteBounds;

    public @NonNull Boolean getInfiniteBounds() {
      return infiniteBounds;
    }

    public void setInfiniteBounds(@NonNull Boolean setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"infiniteBounds\" is null.");
      }
      this.infiniteBounds = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    CoordinateBounds() {}

    public static final class Builder {

      private @Nullable Map<String, Object> southwest;

      public @NonNull Builder setSouthwest(@NonNull Map<String, Object> setterArg) {
        this.southwest = setterArg;
        return this;
      }

      private @Nullable Map<String, Object> northeast;

      public @NonNull Builder setNortheast(@NonNull Map<String, Object> setterArg) {
        this.northeast = setterArg;
        return this;
      }

      private @Nullable Boolean infiniteBounds;

      public @NonNull Builder setInfiniteBounds(@NonNull Boolean setterArg) {
        this.infiniteBounds = setterArg;
        return this;
      }

      public @NonNull CoordinateBounds build() {
        CoordinateBounds pigeonReturn = new CoordinateBounds();
        pigeonReturn.setSouthwest(southwest);
        pigeonReturn.setNortheast(northeast);
        pigeonReturn.setInfiniteBounds(infiniteBounds);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(3);
      toListResult.add(southwest);
      toListResult.add(northeast);
      toListResult.add(infiniteBounds);
      return toListResult;
    }

    static @NonNull CoordinateBounds fromList(@NonNull ArrayList<Object> list) {
      CoordinateBounds pigeonResult = new CoordinateBounds();
      Object southwest = list.get(0);
      pigeonResult.setSouthwest((Map<String, Object>) southwest);
      Object northeast = list.get(1);
      pigeonResult.setNortheast((Map<String, Object>) northeast);
      Object infiniteBounds = list.get(2);
      pigeonResult.setInfiniteBounds((Boolean) infiniteBounds);
      return pigeonResult;
    }
  }

  /**
   * Options for enabling debugging features in a map.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class MapDebugOptions {
    private @NonNull MapDebugOptionsData data;

    public @NonNull MapDebugOptionsData getData() {
      return data;
    }

    public void setData(@NonNull MapDebugOptionsData setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"data\" is null.");
      }
      this.data = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    MapDebugOptions() {}

    public static final class Builder {

      private @Nullable MapDebugOptionsData data;

      public @NonNull Builder setData(@NonNull MapDebugOptionsData setterArg) {
        this.data = setterArg;
        return this;
      }

      public @NonNull MapDebugOptions build() {
        MapDebugOptions pigeonReturn = new MapDebugOptions();
        pigeonReturn.setData(data);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(1);
      toListResult.add(data == null ? null : data.index);
      return toListResult;
    }

    static @NonNull MapDebugOptions fromList(@NonNull ArrayList<Object> list) {
      MapDebugOptions pigeonResult = new MapDebugOptions();
      Object data = list.get(0);
      pigeonResult.setData(MapDebugOptionsData.values()[(int) data]);
      return pigeonResult;
    }
  }

  /**
   * Describes the glyphs rasterization option values.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class GlyphsRasterizationOptions {
    /** Glyphs rasterization mode for client-side text rendering. */
    private @NonNull GlyphsRasterizationMode rasterizationMode;

    public @NonNull GlyphsRasterizationMode getRasterizationMode() {
      return rasterizationMode;
    }

    public void setRasterizationMode(@NonNull GlyphsRasterizationMode setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"rasterizationMode\" is null.");
      }
      this.rasterizationMode = setterArg;
    }

    /**
     * Font family to use as font fallback for client-side text renderings.
     *
     * Note: `GlyphsRasterizationMode` has precedence over font family. If `AllGlyphsRasterizedLocally`
     * or `IdeographsRasterizedLocally` is set, local glyphs will be generated based on the provided font family. If no
     * font family is provided, the map will fall back to use the system default font. The mechanisms of choosing the
     * default font are varied in platforms:
     * - For darwin(iOS/macOS) platform, the default font family is created from the <a href="https://developer.apple.com/documentation/uikit/uifont/1619027-systemfontofsize?language=objc">systemFont</a>.
     *   If provided fonts are not supported on darwin platform, the map will fall back to use the first available font from the global fallback list.
     * - For Android platform: the default font <a href="https://developer.android.com/reference/android/graphics/Typeface#DEFAULT">Typeface.DEFAULT</a> will be used.
     *
     * Besides, the font family will be discarded if it is provided along with `NoGlyphsRasterizedLocally` mode.
     *
     */
    private @Nullable String fontFamily;

    public @Nullable String getFontFamily() {
      return fontFamily;
    }

    public void setFontFamily(@Nullable String setterArg) {
      this.fontFamily = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    GlyphsRasterizationOptions() {}

    public static final class Builder {

      private @Nullable GlyphsRasterizationMode rasterizationMode;

      public @NonNull Builder setRasterizationMode(@NonNull GlyphsRasterizationMode setterArg) {
        this.rasterizationMode = setterArg;
        return this;
      }

      private @Nullable String fontFamily;

      public @NonNull Builder setFontFamily(@Nullable String setterArg) {
        this.fontFamily = setterArg;
        return this;
      }

      public @NonNull GlyphsRasterizationOptions build() {
        GlyphsRasterizationOptions pigeonReturn = new GlyphsRasterizationOptions();
        pigeonReturn.setRasterizationMode(rasterizationMode);
        pigeonReturn.setFontFamily(fontFamily);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(rasterizationMode == null ? null : rasterizationMode.index);
      toListResult.add(fontFamily);
      return toListResult;
    }

    static @NonNull GlyphsRasterizationOptions fromList(@NonNull ArrayList<Object> list) {
      GlyphsRasterizationOptions pigeonResult = new GlyphsRasterizationOptions();
      Object rasterizationMode = list.get(0);
      pigeonResult.setRasterizationMode(GlyphsRasterizationMode.values()[(int) rasterizationMode]);
      Object fontFamily = list.get(1);
      pigeonResult.setFontFamily((String) fontFamily);
      return pigeonResult;
    }
  }

  /**
   * Map memory budget in megabytes.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class MapMemoryBudgetInMegabytes {
    private @NonNull Long size;

    public @NonNull Long getSize() {
      return size;
    }

    public void setSize(@NonNull Long setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"size\" is null.");
      }
      this.size = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    MapMemoryBudgetInMegabytes() {}

    public static final class Builder {

      private @Nullable Long size;

      public @NonNull Builder setSize(@NonNull Long setterArg) {
        this.size = setterArg;
        return this;
      }

      public @NonNull MapMemoryBudgetInMegabytes build() {
        MapMemoryBudgetInMegabytes pigeonReturn = new MapMemoryBudgetInMegabytes();
        pigeonReturn.setSize(size);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(1);
      toListResult.add(size);
      return toListResult;
    }

    static @NonNull MapMemoryBudgetInMegabytes fromList(@NonNull ArrayList<Object> list) {
      MapMemoryBudgetInMegabytes pigeonResult = new MapMemoryBudgetInMegabytes();
      Object size = list.get(0);
      pigeonResult.setSize((size == null) ? null : ((size instanceof Integer) ? (Integer) size : (Long) size));
      return pigeonResult;
    }
  }

  /**
   * Map memory budget in tiles.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class MapMemoryBudgetInTiles {
    private @NonNull Long size;

    public @NonNull Long getSize() {
      return size;
    }

    public void setSize(@NonNull Long setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"size\" is null.");
      }
      this.size = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    MapMemoryBudgetInTiles() {}

    public static final class Builder {

      private @Nullable Long size;

      public @NonNull Builder setSize(@NonNull Long setterArg) {
        this.size = setterArg;
        return this;
      }

      public @NonNull MapMemoryBudgetInTiles build() {
        MapMemoryBudgetInTiles pigeonReturn = new MapMemoryBudgetInTiles();
        pigeonReturn.setSize(size);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(1);
      toListResult.add(size);
      return toListResult;
    }

    static @NonNull MapMemoryBudgetInTiles fromList(@NonNull ArrayList<Object> list) {
      MapMemoryBudgetInTiles pigeonResult = new MapMemoryBudgetInTiles();
      Object size = list.get(0);
      pigeonResult.setSize((size == null) ? null : ((size instanceof Integer) ? (Integer) size : (Long) size));
      return pigeonResult;
    }
  }

  /**
   * Describes the map option values.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class MapOptions {
    /**
     * The map context mode. This can be used to optimizations
     * if we know that the drawing context is not shared with other code.
     */
    private @Nullable ContextMode contextMode;

    public @Nullable ContextMode getContextMode() {
      return contextMode;
    }

    public void setContextMode(@Nullable ContextMode setterArg) {
      this.contextMode = setterArg;
    }

    /**
     * The map constrain mode. This can be used to limit the map
     * to wrap around the globe horizontally. By default, it is set to
     * `HeightOnly`.
     */
    private @Nullable ConstrainMode constrainMode;

    public @Nullable ConstrainMode getConstrainMode() {
      return constrainMode;
    }

    public void setConstrainMode(@Nullable ConstrainMode setterArg) {
      this.constrainMode = setterArg;
    }

    /**
     * The viewport mode. This can be used to flip the vertical
     * orientation of the map as some devices may use inverted orientation.
     */
    private @Nullable ViewportMode viewportMode;

    public @Nullable ViewportMode getViewportMode() {
      return viewportMode;
    }

    public void setViewportMode(@Nullable ViewportMode setterArg) {
      this.viewportMode = setterArg;
    }

    /**
     * The orientation of the Map. By default, it is set to
     * `Upwards`.
     */
    private @Nullable NorthOrientation orientation;

    public @Nullable NorthOrientation getOrientation() {
      return orientation;
    }

    public void setOrientation(@Nullable NorthOrientation setterArg) {
      this.orientation = setterArg;
    }

    /**
     * Specify whether to enable cross-source symbol collision detection
     * or not. By default, it is set to `true`.
     */
    private @Nullable Boolean crossSourceCollisions;

    public @Nullable Boolean getCrossSourceCollisions() {
      return crossSourceCollisions;
    }

    public void setCrossSourceCollisions(@Nullable Boolean setterArg) {
      this.crossSourceCollisions = setterArg;
    }

    /**
     * With terrain on, if `true`, the map will render for performance
     * priority, which may lead to layer reordering allowing to maximize
     * performance (layers that are draped over terrain will be drawn first,
     * including fill, line, background, hillshade and raster). Any layers that
     * are positioned after symbols are draped last, over symbols. Otherwise, if
     * set to `false`, the map will always be drawn for layer order priority.
     * By default, it is set to `true`.
     */
    private @Nullable Boolean optimizeForTerrain;

    public @Nullable Boolean getOptimizeForTerrain() {
      return optimizeForTerrain;
    }

    public void setOptimizeForTerrain(@Nullable Boolean setterArg) {
      this.optimizeForTerrain = setterArg;
    }

    /**
     * The size to resize the map object and renderer backend.
     * The size is given in `platform pixel` units. macOS and iOS platforms use
     * device-independent pixel units, while other platforms, such as Android,
     * use screen pixel units.
     */
    private @Nullable Size size;

    public @Nullable Size getSize() {
      return size;
    }

    public void setSize(@Nullable Size setterArg) {
      this.size = setterArg;
    }

    /** The custom pixel ratio. By default, it is set to 1.0 */
    private @NonNull Double pixelRatio;

    public @NonNull Double getPixelRatio() {
      return pixelRatio;
    }

    public void setPixelRatio(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"pixelRatio\" is null.");
      }
      this.pixelRatio = setterArg;
    }

    /** Glyphs rasterization options to use for client-side text rendering. */
    private @Nullable GlyphsRasterizationOptions glyphsRasterizationOptions;

    public @Nullable GlyphsRasterizationOptions getGlyphsRasterizationOptions() {
      return glyphsRasterizationOptions;
    }

    public void setGlyphsRasterizationOptions(@Nullable GlyphsRasterizationOptions setterArg) {
      this.glyphsRasterizationOptions = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    MapOptions() {}

    public static final class Builder {

      private @Nullable ContextMode contextMode;

      public @NonNull Builder setContextMode(@Nullable ContextMode setterArg) {
        this.contextMode = setterArg;
        return this;
      }

      private @Nullable ConstrainMode constrainMode;

      public @NonNull Builder setConstrainMode(@Nullable ConstrainMode setterArg) {
        this.constrainMode = setterArg;
        return this;
      }

      private @Nullable ViewportMode viewportMode;

      public @NonNull Builder setViewportMode(@Nullable ViewportMode setterArg) {
        this.viewportMode = setterArg;
        return this;
      }

      private @Nullable NorthOrientation orientation;

      public @NonNull Builder setOrientation(@Nullable NorthOrientation setterArg) {
        this.orientation = setterArg;
        return this;
      }

      private @Nullable Boolean crossSourceCollisions;

      public @NonNull Builder setCrossSourceCollisions(@Nullable Boolean setterArg) {
        this.crossSourceCollisions = setterArg;
        return this;
      }

      private @Nullable Boolean optimizeForTerrain;

      public @NonNull Builder setOptimizeForTerrain(@Nullable Boolean setterArg) {
        this.optimizeForTerrain = setterArg;
        return this;
      }

      private @Nullable Size size;

      public @NonNull Builder setSize(@Nullable Size setterArg) {
        this.size = setterArg;
        return this;
      }

      private @Nullable Double pixelRatio;

      public @NonNull Builder setPixelRatio(@NonNull Double setterArg) {
        this.pixelRatio = setterArg;
        return this;
      }

      private @Nullable GlyphsRasterizationOptions glyphsRasterizationOptions;

      public @NonNull Builder setGlyphsRasterizationOptions(@Nullable GlyphsRasterizationOptions setterArg) {
        this.glyphsRasterizationOptions = setterArg;
        return this;
      }

      public @NonNull MapOptions build() {
        MapOptions pigeonReturn = new MapOptions();
        pigeonReturn.setContextMode(contextMode);
        pigeonReturn.setConstrainMode(constrainMode);
        pigeonReturn.setViewportMode(viewportMode);
        pigeonReturn.setOrientation(orientation);
        pigeonReturn.setCrossSourceCollisions(crossSourceCollisions);
        pigeonReturn.setOptimizeForTerrain(optimizeForTerrain);
        pigeonReturn.setSize(size);
        pigeonReturn.setPixelRatio(pixelRatio);
        pigeonReturn.setGlyphsRasterizationOptions(glyphsRasterizationOptions);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(9);
      toListResult.add(contextMode == null ? null : contextMode.index);
      toListResult.add(constrainMode == null ? null : constrainMode.index);
      toListResult.add(viewportMode == null ? null : viewportMode.index);
      toListResult.add(orientation == null ? null : orientation.index);
      toListResult.add(crossSourceCollisions);
      toListResult.add(optimizeForTerrain);
      toListResult.add((size == null) ? null : size.toList());
      toListResult.add(pixelRatio);
      toListResult.add((glyphsRasterizationOptions == null) ? null : glyphsRasterizationOptions.toList());
      return toListResult;
    }

    static @NonNull MapOptions fromList(@NonNull ArrayList<Object> list) {
      MapOptions pigeonResult = new MapOptions();
      Object contextMode = list.get(0);
      pigeonResult.setContextMode(contextMode == null ? null : ContextMode.values()[(int) contextMode]);
      Object constrainMode = list.get(1);
      pigeonResult.setConstrainMode(constrainMode == null ? null : ConstrainMode.values()[(int) constrainMode]);
      Object viewportMode = list.get(2);
      pigeonResult.setViewportMode(viewportMode == null ? null : ViewportMode.values()[(int) viewportMode]);
      Object orientation = list.get(3);
      pigeonResult.setOrientation(orientation == null ? null : NorthOrientation.values()[(int) orientation]);
      Object crossSourceCollisions = list.get(4);
      pigeonResult.setCrossSourceCollisions((Boolean) crossSourceCollisions);
      Object optimizeForTerrain = list.get(5);
      pigeonResult.setOptimizeForTerrain((Boolean) optimizeForTerrain);
      Object size = list.get(6);
      pigeonResult.setSize((size == null) ? null : Size.fromList((ArrayList<Object>) size));
      Object pixelRatio = list.get(7);
      pigeonResult.setPixelRatio((Double) pixelRatio);
      Object glyphsRasterizationOptions = list.get(8);
      pigeonResult.setGlyphsRasterizationOptions((glyphsRasterizationOptions == null) ? null : GlyphsRasterizationOptions.fromList((ArrayList<Object>) glyphsRasterizationOptions));
      return pigeonResult;
    }
  }

  /**
   * Describes the coordinate on the screen, measured from top to bottom and from left to right.
   * Note: the `map` uses screen coordinate units measured in `platform pixels`.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class ScreenCoordinate {
    /** A value representing the x position of this coordinate. */
    private @NonNull Double x;

    public @NonNull Double getX() {
      return x;
    }

    public void setX(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"x\" is null.");
      }
      this.x = setterArg;
    }

    /** A value representing the y position of this coordinate. */
    private @NonNull Double y;

    public @NonNull Double getY() {
      return y;
    }

    public void setY(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"y\" is null.");
      }
      this.y = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    ScreenCoordinate() {}

    public static final class Builder {

      private @Nullable Double x;

      public @NonNull Builder setX(@NonNull Double setterArg) {
        this.x = setterArg;
        return this;
      }

      private @Nullable Double y;

      public @NonNull Builder setY(@NonNull Double setterArg) {
        this.y = setterArg;
        return this;
      }

      public @NonNull ScreenCoordinate build() {
        ScreenCoordinate pigeonReturn = new ScreenCoordinate();
        pigeonReturn.setX(x);
        pigeonReturn.setY(y);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(x);
      toListResult.add(y);
      return toListResult;
    }

    static @NonNull ScreenCoordinate fromList(@NonNull ArrayList<Object> list) {
      ScreenCoordinate pigeonResult = new ScreenCoordinate();
      Object x = list.get(0);
      pigeonResult.setX((Double) x);
      Object y = list.get(1);
      pigeonResult.setY((Double) y);
      return pigeonResult;
    }
  }

  /**
   * Describes the coordinate box on the screen, measured in `platform pixels`
   * from top to bottom and from left to right.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class ScreenBox {
    /** The screen coordinate close to the top left corner of the screen. */
    private @NonNull ScreenCoordinate min;

    public @NonNull ScreenCoordinate getMin() {
      return min;
    }

    public void setMin(@NonNull ScreenCoordinate setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"min\" is null.");
      }
      this.min = setterArg;
    }

    /** The screen coordinate close to the bottom right corner of the screen. */
    private @NonNull ScreenCoordinate max;

    public @NonNull ScreenCoordinate getMax() {
      return max;
    }

    public void setMax(@NonNull ScreenCoordinate setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"max\" is null.");
      }
      this.max = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    ScreenBox() {}

    public static final class Builder {

      private @Nullable ScreenCoordinate min;

      public @NonNull Builder setMin(@NonNull ScreenCoordinate setterArg) {
        this.min = setterArg;
        return this;
      }

      private @Nullable ScreenCoordinate max;

      public @NonNull Builder setMax(@NonNull ScreenCoordinate setterArg) {
        this.max = setterArg;
        return this;
      }

      public @NonNull ScreenBox build() {
        ScreenBox pigeonReturn = new ScreenBox();
        pigeonReturn.setMin(min);
        pigeonReturn.setMax(max);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add((min == null) ? null : min.toList());
      toListResult.add((max == null) ? null : max.toList());
      return toListResult;
    }

    static @NonNull ScreenBox fromList(@NonNull ArrayList<Object> list) {
      ScreenBox pigeonResult = new ScreenBox();
      Object min = list.get(0);
      pigeonResult.setMin((min == null) ? null : ScreenCoordinate.fromList((ArrayList<Object>) min));
      Object max = list.get(1);
      pigeonResult.setMax((max == null) ? null : ScreenCoordinate.fromList((ArrayList<Object>) max));
      return pigeonResult;
    }
  }

  /**
   * A coordinate bounds and zoom.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class CoordinateBoundsZoom {
    /** The latitude and longitude bounds. */
    private @NonNull CoordinateBounds bounds;

    public @NonNull CoordinateBounds getBounds() {
      return bounds;
    }

    public void setBounds(@NonNull CoordinateBounds setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"bounds\" is null.");
      }
      this.bounds = setterArg;
    }

    /** Zoom. */
    private @NonNull Double zoom;

    public @NonNull Double getZoom() {
      return zoom;
    }

    public void setZoom(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"zoom\" is null.");
      }
      this.zoom = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    CoordinateBoundsZoom() {}

    public static final class Builder {

      private @Nullable CoordinateBounds bounds;

      public @NonNull Builder setBounds(@NonNull CoordinateBounds setterArg) {
        this.bounds = setterArg;
        return this;
      }

      private @Nullable Double zoom;

      public @NonNull Builder setZoom(@NonNull Double setterArg) {
        this.zoom = setterArg;
        return this;
      }

      public @NonNull CoordinateBoundsZoom build() {
        CoordinateBoundsZoom pigeonReturn = new CoordinateBoundsZoom();
        pigeonReturn.setBounds(bounds);
        pigeonReturn.setZoom(zoom);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add((bounds == null) ? null : bounds.toList());
      toListResult.add(zoom);
      return toListResult;
    }

    static @NonNull CoordinateBoundsZoom fromList(@NonNull ArrayList<Object> list) {
      CoordinateBoundsZoom pigeonResult = new CoordinateBoundsZoom();
      Object bounds = list.get(0);
      pigeonResult.setBounds((bounds == null) ? null : CoordinateBounds.fromList((ArrayList<Object>) bounds));
      Object zoom = list.get(1);
      pigeonResult.setZoom((Double) zoom);
      return pigeonResult;
    }
  }

  /**
   * Size type.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class Size {
    /** Width of the size. */
    private @NonNull Double width;

    public @NonNull Double getWidth() {
      return width;
    }

    public void setWidth(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"width\" is null.");
      }
      this.width = setterArg;
    }

    /** Height of the size. */
    private @NonNull Double height;

    public @NonNull Double getHeight() {
      return height;
    }

    public void setHeight(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"height\" is null.");
      }
      this.height = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    Size() {}

    public static final class Builder {

      private @Nullable Double width;

      public @NonNull Builder setWidth(@NonNull Double setterArg) {
        this.width = setterArg;
        return this;
      }

      private @Nullable Double height;

      public @NonNull Builder setHeight(@NonNull Double setterArg) {
        this.height = setterArg;
        return this;
      }

      public @NonNull Size build() {
        Size pigeonReturn = new Size();
        pigeonReturn.setWidth(width);
        pigeonReturn.setHeight(height);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(width);
      toListResult.add(height);
      return toListResult;
    }

    static @NonNull Size fromList(@NonNull ArrayList<Object> list) {
      Size pigeonResult = new Size();
      Object width = list.get(0);
      pigeonResult.setWidth((Double) width);
      Object height = list.get(1);
      pigeonResult.setHeight((Double) height);
      return pigeonResult;
    }
  }

  /**
   * Options for querying rendered features.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class RenderedQueryOptions {
    /** Layer IDs to include in the query. */
    private @Nullable List<String> layerIds;

    public @Nullable List<String> getLayerIds() {
      return layerIds;
    }

    public void setLayerIds(@Nullable List<String> setterArg) {
      this.layerIds = setterArg;
    }

    /** Filters the returned features with an expression */
    private @Nullable String filter;

    public @Nullable String getFilter() {
      return filter;
    }

    public void setFilter(@Nullable String setterArg) {
      this.filter = setterArg;
    }

    public static final class Builder {

      private @Nullable List<String> layerIds;

      public @NonNull Builder setLayerIds(@Nullable List<String> setterArg) {
        this.layerIds = setterArg;
        return this;
      }

      private @Nullable String filter;

      public @NonNull Builder setFilter(@Nullable String setterArg) {
        this.filter = setterArg;
        return this;
      }

      public @NonNull RenderedQueryOptions build() {
        RenderedQueryOptions pigeonReturn = new RenderedQueryOptions();
        pigeonReturn.setLayerIds(layerIds);
        pigeonReturn.setFilter(filter);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(layerIds);
      toListResult.add(filter);
      return toListResult;
    }

    static @NonNull RenderedQueryOptions fromList(@NonNull ArrayList<Object> list) {
      RenderedQueryOptions pigeonResult = new RenderedQueryOptions();
      Object layerIds = list.get(0);
      pigeonResult.setLayerIds((List<String>) layerIds);
      Object filter = list.get(1);
      pigeonResult.setFilter((String) filter);
      return pigeonResult;
    }
  }

  /**
   * Options for querying source features.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class SourceQueryOptions {
    /** Source layer IDs to include in the query. */
    private @Nullable List<String> sourceLayerIds;

    public @Nullable List<String> getSourceLayerIds() {
      return sourceLayerIds;
    }

    public void setSourceLayerIds(@Nullable List<String> setterArg) {
      this.sourceLayerIds = setterArg;
    }

    /** Filters the returned features with an expression */
    private @NonNull String filter;

    public @NonNull String getFilter() {
      return filter;
    }

    public void setFilter(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"filter\" is null.");
      }
      this.filter = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    SourceQueryOptions() {}

    public static final class Builder {

      private @Nullable List<String> sourceLayerIds;

      public @NonNull Builder setSourceLayerIds(@Nullable List<String> setterArg) {
        this.sourceLayerIds = setterArg;
        return this;
      }

      private @Nullable String filter;

      public @NonNull Builder setFilter(@NonNull String setterArg) {
        this.filter = setterArg;
        return this;
      }

      public @NonNull SourceQueryOptions build() {
        SourceQueryOptions pigeonReturn = new SourceQueryOptions();
        pigeonReturn.setSourceLayerIds(sourceLayerIds);
        pigeonReturn.setFilter(filter);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(sourceLayerIds);
      toListResult.add(filter);
      return toListResult;
    }

    static @NonNull SourceQueryOptions fromList(@NonNull ArrayList<Object> list) {
      SourceQueryOptions pigeonResult = new SourceQueryOptions();
      Object sourceLayerIds = list.get(0);
      pigeonResult.setSourceLayerIds((List<String>) sourceLayerIds);
      Object filter = list.get(1);
      pigeonResult.setFilter((String) filter);
      return pigeonResult;
    }
  }

  /**
   * A value or a collection of a feature extension.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class FeatureExtensionValue {
    /** An optional value of a feature extension */
    private @Nullable String value;

    public @Nullable String getValue() {
      return value;
    }

    public void setValue(@Nullable String setterArg) {
      this.value = setterArg;
    }

    /** An optional array of features from a feature extension. */
    private @Nullable List<Map<String, Object>> featureCollection;

    public @Nullable List<Map<String, Object>> getFeatureCollection() {
      return featureCollection;
    }

    public void setFeatureCollection(@Nullable List<Map<String, Object>> setterArg) {
      this.featureCollection = setterArg;
    }

    public static final class Builder {

      private @Nullable String value;

      public @NonNull Builder setValue(@Nullable String setterArg) {
        this.value = setterArg;
        return this;
      }

      private @Nullable List<Map<String, Object>> featureCollection;

      public @NonNull Builder setFeatureCollection(@Nullable List<Map<String, Object>> setterArg) {
        this.featureCollection = setterArg;
        return this;
      }

      public @NonNull FeatureExtensionValue build() {
        FeatureExtensionValue pigeonReturn = new FeatureExtensionValue();
        pigeonReturn.setValue(value);
        pigeonReturn.setFeatureCollection(featureCollection);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(value);
      toListResult.add(featureCollection);
      return toListResult;
    }

    static @NonNull FeatureExtensionValue fromList(@NonNull ArrayList<Object> list) {
      FeatureExtensionValue pigeonResult = new FeatureExtensionValue();
      Object value = list.get(0);
      pigeonResult.setValue((String) value);
      Object featureCollection = list.get(1);
      pigeonResult.setFeatureCollection((List<Map<String, Object>>) featureCollection);
      return pigeonResult;
    }
  }

  /**
   * Specifies position of a layer that is added via addStyleLayer method.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class LayerPosition {
    /** Layer should be positioned above specified layer id. */
    private @Nullable String above;

    public @Nullable String getAbove() {
      return above;
    }

    public void setAbove(@Nullable String setterArg) {
      this.above = setterArg;
    }

    /** Layer should be positioned below specified layer id. */
    private @Nullable String below;

    public @Nullable String getBelow() {
      return below;
    }

    public void setBelow(@Nullable String setterArg) {
      this.below = setterArg;
    }

    /** Layer should be positioned at specified index in a layers stack. */
    private @Nullable Long at;

    public @Nullable Long getAt() {
      return at;
    }

    public void setAt(@Nullable Long setterArg) {
      this.at = setterArg;
    }

    public static final class Builder {

      private @Nullable String above;

      public @NonNull Builder setAbove(@Nullable String setterArg) {
        this.above = setterArg;
        return this;
      }

      private @Nullable String below;

      public @NonNull Builder setBelow(@Nullable String setterArg) {
        this.below = setterArg;
        return this;
      }

      private @Nullable Long at;

      public @NonNull Builder setAt(@Nullable Long setterArg) {
        this.at = setterArg;
        return this;
      }

      public @NonNull LayerPosition build() {
        LayerPosition pigeonReturn = new LayerPosition();
        pigeonReturn.setAbove(above);
        pigeonReturn.setBelow(below);
        pigeonReturn.setAt(at);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(3);
      toListResult.add(above);
      toListResult.add(below);
      toListResult.add(at);
      return toListResult;
    }

    static @NonNull LayerPosition fromList(@NonNull ArrayList<Object> list) {
      LayerPosition pigeonResult = new LayerPosition();
      Object above = list.get(0);
      pigeonResult.setAbove((String) above);
      Object below = list.get(1);
      pigeonResult.setBelow((String) below);
      Object at = list.get(2);
      pigeonResult.setAt((at == null) ? null : ((at instanceof Integer) ? (Integer) at : (Long) at));
      return pigeonResult;
    }
  }

  /**
   * Represents query result that is returned in QueryFeaturesCallback.
   * @see `queryRenderedFeatures` or `querySourceFeatures`
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class QueriedFeature {
    /** Feature returned by the query. */
    private @NonNull Map<String, Object> feature;

    public @NonNull Map<String, Object> getFeature() {
      return feature;
    }

    public void setFeature(@NonNull Map<String, Object> setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"feature\" is null.");
      }
      this.feature = setterArg;
    }

    /** Source id for a queried feature. */
    private @NonNull String source;

    public @NonNull String getSource() {
      return source;
    }

    public void setSource(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"source\" is null.");
      }
      this.source = setterArg;
    }

    /**
     * Source layer id for a queried feature. May be null if source does not support layers, e.g., 'geojson' source,
     * or when data provided by the source is not layered.
     */
    private @Nullable String sourceLayer;

    public @Nullable String getSourceLayer() {
      return sourceLayer;
    }

    public void setSourceLayer(@Nullable String setterArg) {
      this.sourceLayer = setterArg;
    }

    /**
     * Feature state for a queried feature. Type of the value is an Object.
     * @see `setFeatureState` and `getFeatureState`
     */
    private @NonNull String state;

    public @NonNull String getState() {
      return state;
    }

    public void setState(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"state\" is null.");
      }
      this.state = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    QueriedFeature() {}

    public static final class Builder {

      private @Nullable Map<String, Object> feature;

      public @NonNull Builder setFeature(@NonNull Map<String, Object> setterArg) {
        this.feature = setterArg;
        return this;
      }

      private @Nullable String source;

      public @NonNull Builder setSource(@NonNull String setterArg) {
        this.source = setterArg;
        return this;
      }

      private @Nullable String sourceLayer;

      public @NonNull Builder setSourceLayer(@Nullable String setterArg) {
        this.sourceLayer = setterArg;
        return this;
      }

      private @Nullable String state;

      public @NonNull Builder setState(@NonNull String setterArg) {
        this.state = setterArg;
        return this;
      }

      public @NonNull QueriedFeature build() {
        QueriedFeature pigeonReturn = new QueriedFeature();
        pigeonReturn.setFeature(feature);
        pigeonReturn.setSource(source);
        pigeonReturn.setSourceLayer(sourceLayer);
        pigeonReturn.setState(state);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(4);
      toListResult.add(feature);
      toListResult.add(source);
      toListResult.add(sourceLayer);
      toListResult.add(state);
      return toListResult;
    }

    static @NonNull QueriedFeature fromList(@NonNull ArrayList<Object> list) {
      QueriedFeature pigeonResult = new QueriedFeature();
      Object feature = list.get(0);
      pigeonResult.setFeature((Map<String, Object>) feature);
      Object source = list.get(1);
      pigeonResult.setSource((String) source);
      Object sourceLayer = list.get(2);
      pigeonResult.setSourceLayer((String) sourceLayer);
      Object state = list.get(3);
      pigeonResult.setState((String) state);
      return pigeonResult;
    }
  }

  /**
   * Geometry for querying rendered features.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class RenderedQueryGeometry {
    /** ScreenCoordinate/List<ScreenCoordinate>/ScreenBox in Json mode. */
    private @NonNull String value;

    public @NonNull String getValue() {
      return value;
    }

    public void setValue(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"value\" is null.");
      }
      this.value = setterArg;
    }

    private @NonNull Type type;

    public @NonNull Type getType() {
      return type;
    }

    public void setType(@NonNull Type setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"type\" is null.");
      }
      this.type = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    RenderedQueryGeometry() {}

    public static final class Builder {

      private @Nullable String value;

      public @NonNull Builder setValue(@NonNull String setterArg) {
        this.value = setterArg;
        return this;
      }

      private @Nullable Type type;

      public @NonNull Builder setType(@NonNull Type setterArg) {
        this.type = setterArg;
        return this;
      }

      public @NonNull RenderedQueryGeometry build() {
        RenderedQueryGeometry pigeonReturn = new RenderedQueryGeometry();
        pigeonReturn.setValue(value);
        pigeonReturn.setType(type);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(value);
      toListResult.add(type == null ? null : type.index);
      return toListResult;
    }

    static @NonNull RenderedQueryGeometry fromList(@NonNull ArrayList<Object> list) {
      RenderedQueryGeometry pigeonResult = new RenderedQueryGeometry();
      Object value = list.get(0);
      pigeonResult.setValue((String) value);
      Object type = list.get(1);
      pigeonResult.setType(Type.values()[(int) type]);
      return pigeonResult;
    }
  }

  /**
   * An offline region definition is a geographic region defined by a style URL,
   * a geometry, zoom range, and device pixel ratio. Both `minZoom` and `maxZoom` must be ≥ 0,
   * and `maxZoom` must be ≥ `minZoom`. The `maxZoom` may be ∞, in which case for each tile source,
   * the region will include tiles from `minZoom` up to the maximum zoom level provided by that source.
   * The `pixelRatio` must be ≥ 0 and should typically be 1.0 or 2.0.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class OfflineRegionGeometryDefinition {
    /** The style associated with the offline region */
    private @NonNull String styleURL;

    public @NonNull String getStyleURL() {
      return styleURL;
    }

    public void setStyleURL(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"styleURL\" is null.");
      }
      this.styleURL = setterArg;
    }

    /** The geometry that defines the boundary of the offline region */
    private @NonNull Map<String, Object> geometry;

    public @NonNull Map<String, Object> getGeometry() {
      return geometry;
    }

    public void setGeometry(@NonNull Map<String, Object> setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"geometry\" is null.");
      }
      this.geometry = setterArg;
    }

    /** Minimum zoom level for the offline region */
    private @NonNull Double minZoom;

    public @NonNull Double getMinZoom() {
      return minZoom;
    }

    public void setMinZoom(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"minZoom\" is null.");
      }
      this.minZoom = setterArg;
    }

    /** Maximum zoom level for the offline region */
    private @NonNull Double maxZoom;

    public @NonNull Double getMaxZoom() {
      return maxZoom;
    }

    public void setMaxZoom(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"maxZoom\" is null.");
      }
      this.maxZoom = setterArg;
    }

    /** Pixel ratio to be accounted for when downloading assets */
    private @NonNull Double pixelRatio;

    public @NonNull Double getPixelRatio() {
      return pixelRatio;
    }

    public void setPixelRatio(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"pixelRatio\" is null.");
      }
      this.pixelRatio = setterArg;
    }

    /** Specifies glyphs rasterization mode. It defines which glyphs will be loaded from the server */
    private @NonNull GlyphsRasterizationMode glyphsRasterizationMode;

    public @NonNull GlyphsRasterizationMode getGlyphsRasterizationMode() {
      return glyphsRasterizationMode;
    }

    public void setGlyphsRasterizationMode(@NonNull GlyphsRasterizationMode setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"glyphsRasterizationMode\" is null.");
      }
      this.glyphsRasterizationMode = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    OfflineRegionGeometryDefinition() {}

    public static final class Builder {

      private @Nullable String styleURL;

      public @NonNull Builder setStyleURL(@NonNull String setterArg) {
        this.styleURL = setterArg;
        return this;
      }

      private @Nullable Map<String, Object> geometry;

      public @NonNull Builder setGeometry(@NonNull Map<String, Object> setterArg) {
        this.geometry = setterArg;
        return this;
      }

      private @Nullable Double minZoom;

      public @NonNull Builder setMinZoom(@NonNull Double setterArg) {
        this.minZoom = setterArg;
        return this;
      }

      private @Nullable Double maxZoom;

      public @NonNull Builder setMaxZoom(@NonNull Double setterArg) {
        this.maxZoom = setterArg;
        return this;
      }

      private @Nullable Double pixelRatio;

      public @NonNull Builder setPixelRatio(@NonNull Double setterArg) {
        this.pixelRatio = setterArg;
        return this;
      }

      private @Nullable GlyphsRasterizationMode glyphsRasterizationMode;

      public @NonNull Builder setGlyphsRasterizationMode(@NonNull GlyphsRasterizationMode setterArg) {
        this.glyphsRasterizationMode = setterArg;
        return this;
      }

      public @NonNull OfflineRegionGeometryDefinition build() {
        OfflineRegionGeometryDefinition pigeonReturn = new OfflineRegionGeometryDefinition();
        pigeonReturn.setStyleURL(styleURL);
        pigeonReturn.setGeometry(geometry);
        pigeonReturn.setMinZoom(minZoom);
        pigeonReturn.setMaxZoom(maxZoom);
        pigeonReturn.setPixelRatio(pixelRatio);
        pigeonReturn.setGlyphsRasterizationMode(glyphsRasterizationMode);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(6);
      toListResult.add(styleURL);
      toListResult.add(geometry);
      toListResult.add(minZoom);
      toListResult.add(maxZoom);
      toListResult.add(pixelRatio);
      toListResult.add(glyphsRasterizationMode == null ? null : glyphsRasterizationMode.index);
      return toListResult;
    }

    static @NonNull OfflineRegionGeometryDefinition fromList(@NonNull ArrayList<Object> list) {
      OfflineRegionGeometryDefinition pigeonResult = new OfflineRegionGeometryDefinition();
      Object styleURL = list.get(0);
      pigeonResult.setStyleURL((String) styleURL);
      Object geometry = list.get(1);
      pigeonResult.setGeometry((Map<String, Object>) geometry);
      Object minZoom = list.get(2);
      pigeonResult.setMinZoom((Double) minZoom);
      Object maxZoom = list.get(3);
      pigeonResult.setMaxZoom((Double) maxZoom);
      Object pixelRatio = list.get(4);
      pigeonResult.setPixelRatio((Double) pixelRatio);
      Object glyphsRasterizationMode = list.get(5);
      pigeonResult.setGlyphsRasterizationMode(GlyphsRasterizationMode.values()[(int) glyphsRasterizationMode]);
      return pigeonResult;
    }
  }

  /**
   * An offline region definition is a geographic region defined by a style URL,
   * geographic bounding box, zoom range, and device pixel ratio. Both `minZoom` and `maxZoom` must be ≥ 0,
   * and `maxZoom` must be ≥ `minZoom`. The `maxZoom` may be ∞, in which case for each tile source,
   * the region will include tiles from `minZoom` up to the maximum zoom level provided by that source.
   * The `pixelRatio` must be ≥ 0 and should typically be 1.0 or 2.0.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class OfflineRegionTilePyramidDefinition {
    /** The style associated with the offline region. */
    private @NonNull String styleURL;

    public @NonNull String getStyleURL() {
      return styleURL;
    }

    public void setStyleURL(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"styleURL\" is null.");
      }
      this.styleURL = setterArg;
    }

    /** The bounds covering the region. */
    private @NonNull CoordinateBounds bounds;

    public @NonNull CoordinateBounds getBounds() {
      return bounds;
    }

    public void setBounds(@NonNull CoordinateBounds setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"bounds\" is null.");
      }
      this.bounds = setterArg;
    }

    /** Minimum zoom level for the offline region. */
    private @NonNull Double minZoom;

    public @NonNull Double getMinZoom() {
      return minZoom;
    }

    public void setMinZoom(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"minZoom\" is null.");
      }
      this.minZoom = setterArg;
    }

    /** Maximum zoom level for the offline region. */
    private @NonNull Double maxZoom;

    public @NonNull Double getMaxZoom() {
      return maxZoom;
    }

    public void setMaxZoom(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"maxZoom\" is null.");
      }
      this.maxZoom = setterArg;
    }

    /** Pixel ratio to be accounted for when downloading assets. */
    private @NonNull Double pixelRatio;

    public @NonNull Double getPixelRatio() {
      return pixelRatio;
    }

    public void setPixelRatio(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"pixelRatio\" is null.");
      }
      this.pixelRatio = setterArg;
    }

    /** Specifies glyphs download mode. */
    private @NonNull GlyphsRasterizationMode glyphsRasterizationMode;

    public @NonNull GlyphsRasterizationMode getGlyphsRasterizationMode() {
      return glyphsRasterizationMode;
    }

    public void setGlyphsRasterizationMode(@NonNull GlyphsRasterizationMode setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"glyphsRasterizationMode\" is null.");
      }
      this.glyphsRasterizationMode = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    OfflineRegionTilePyramidDefinition() {}

    public static final class Builder {

      private @Nullable String styleURL;

      public @NonNull Builder setStyleURL(@NonNull String setterArg) {
        this.styleURL = setterArg;
        return this;
      }

      private @Nullable CoordinateBounds bounds;

      public @NonNull Builder setBounds(@NonNull CoordinateBounds setterArg) {
        this.bounds = setterArg;
        return this;
      }

      private @Nullable Double minZoom;

      public @NonNull Builder setMinZoom(@NonNull Double setterArg) {
        this.minZoom = setterArg;
        return this;
      }

      private @Nullable Double maxZoom;

      public @NonNull Builder setMaxZoom(@NonNull Double setterArg) {
        this.maxZoom = setterArg;
        return this;
      }

      private @Nullable Double pixelRatio;

      public @NonNull Builder setPixelRatio(@NonNull Double setterArg) {
        this.pixelRatio = setterArg;
        return this;
      }

      private @Nullable GlyphsRasterizationMode glyphsRasterizationMode;

      public @NonNull Builder setGlyphsRasterizationMode(@NonNull GlyphsRasterizationMode setterArg) {
        this.glyphsRasterizationMode = setterArg;
        return this;
      }

      public @NonNull OfflineRegionTilePyramidDefinition build() {
        OfflineRegionTilePyramidDefinition pigeonReturn = new OfflineRegionTilePyramidDefinition();
        pigeonReturn.setStyleURL(styleURL);
        pigeonReturn.setBounds(bounds);
        pigeonReturn.setMinZoom(minZoom);
        pigeonReturn.setMaxZoom(maxZoom);
        pigeonReturn.setPixelRatio(pixelRatio);
        pigeonReturn.setGlyphsRasterizationMode(glyphsRasterizationMode);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(6);
      toListResult.add(styleURL);
      toListResult.add((bounds == null) ? null : bounds.toList());
      toListResult.add(minZoom);
      toListResult.add(maxZoom);
      toListResult.add(pixelRatio);
      toListResult.add(glyphsRasterizationMode == null ? null : glyphsRasterizationMode.index);
      return toListResult;
    }

    static @NonNull OfflineRegionTilePyramidDefinition fromList(@NonNull ArrayList<Object> list) {
      OfflineRegionTilePyramidDefinition pigeonResult = new OfflineRegionTilePyramidDefinition();
      Object styleURL = list.get(0);
      pigeonResult.setStyleURL((String) styleURL);
      Object bounds = list.get(1);
      pigeonResult.setBounds((bounds == null) ? null : CoordinateBounds.fromList((ArrayList<Object>) bounds));
      Object minZoom = list.get(2);
      pigeonResult.setMinZoom((Double) minZoom);
      Object maxZoom = list.get(3);
      pigeonResult.setMaxZoom((Double) maxZoom);
      Object pixelRatio = list.get(4);
      pigeonResult.setPixelRatio((Double) pixelRatio);
      Object glyphsRasterizationMode = list.get(5);
      pigeonResult.setGlyphsRasterizationMode(GlyphsRasterizationMode.values()[(int) glyphsRasterizationMode]);
      return pigeonResult;
    }
  }

  /**
   * ProjectedMeters is a coordinate in a specific
   * [Spherical Mercator](http://docs.openlayers.org/library/spherical_mercator.html) projection.
   *
   * This specific Spherical Mercator projection assumes the Earth is a sphere with a radius
   * of 6,378,137 meters. Coordinates are determined as distances, in meters, on the surface
   * of that sphere.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class ProjectedMeters {
    /** Projected meters in north direction. */
    private @NonNull Double northing;

    public @NonNull Double getNorthing() {
      return northing;
    }

    public void setNorthing(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"northing\" is null.");
      }
      this.northing = setterArg;
    }

    /** Projected meters in east direction. */
    private @NonNull Double easting;

    public @NonNull Double getEasting() {
      return easting;
    }

    public void setEasting(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"easting\" is null.");
      }
      this.easting = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    ProjectedMeters() {}

    public static final class Builder {

      private @Nullable Double northing;

      public @NonNull Builder setNorthing(@NonNull Double setterArg) {
        this.northing = setterArg;
        return this;
      }

      private @Nullable Double easting;

      public @NonNull Builder setEasting(@NonNull Double setterArg) {
        this.easting = setterArg;
        return this;
      }

      public @NonNull ProjectedMeters build() {
        ProjectedMeters pigeonReturn = new ProjectedMeters();
        pigeonReturn.setNorthing(northing);
        pigeonReturn.setEasting(easting);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(northing);
      toListResult.add(easting);
      return toListResult;
    }

    static @NonNull ProjectedMeters fromList(@NonNull ArrayList<Object> list) {
      ProjectedMeters pigeonResult = new ProjectedMeters();
      Object northing = list.get(0);
      pigeonResult.setNorthing((Double) northing);
      Object easting = list.get(1);
      pigeonResult.setEasting((Double) easting);
      return pigeonResult;
    }
  }

  /**
   * Describes a point on the map in Mercator projection.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class MercatorCoordinate {
    /** A value representing the x position of this coordinate. */
    private @NonNull Double x;

    public @NonNull Double getX() {
      return x;
    }

    public void setX(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"x\" is null.");
      }
      this.x = setterArg;
    }

    /** A value representing the y position of this coordinate. */
    private @NonNull Double y;

    public @NonNull Double getY() {
      return y;
    }

    public void setY(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"y\" is null.");
      }
      this.y = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    MercatorCoordinate() {}

    public static final class Builder {

      private @Nullable Double x;

      public @NonNull Builder setX(@NonNull Double setterArg) {
        this.x = setterArg;
        return this;
      }

      private @Nullable Double y;

      public @NonNull Builder setY(@NonNull Double setterArg) {
        this.y = setterArg;
        return this;
      }

      public @NonNull MercatorCoordinate build() {
        MercatorCoordinate pigeonReturn = new MercatorCoordinate();
        pigeonReturn.setX(x);
        pigeonReturn.setY(y);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(x);
      toListResult.add(y);
      return toListResult;
    }

    static @NonNull MercatorCoordinate fromList(@NonNull ArrayList<Object> list) {
      MercatorCoordinate pigeonResult = new MercatorCoordinate();
      Object x = list.get(0);
      pigeonResult.setX((Double) x);
      Object y = list.get(1);
      pigeonResult.setY((Double) y);
      return pigeonResult;
    }
  }

  /**
   * Options to configure a resource
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class ResourceOptions {
    /** The access token that is used to access resources provided by Mapbox services. */
    private @NonNull String accessToken;

    public @NonNull String getAccessToken() {
      return accessToken;
    }

    public void setAccessToken(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"accessToken\" is null.");
      }
      this.accessToken = setterArg;
    }

    /** The base URL that would be used to make HTTP requests. By default it is `https://api.mapbox.com`. */
    private @Nullable String baseURL;

    public @Nullable String getBaseURL() {
      return baseURL;
    }

    public void setBaseURL(@Nullable String setterArg) {
      this.baseURL = setterArg;
    }

    /**
     * The path to the map data folder.
     *
     * The implementation will use this folder for storing offline style packages and temporary data.
     *
     * The application must have sufficient permissions to create files within the provided directory.
     * If a dataPath is not provided, the default location will be used (the application data path defined
     * in the `Mapbox Common SystemInformation API`).
     */
    private @Nullable String dataPath;

    public @Nullable String getDataPath() {
      return dataPath;
    }

    public void setDataPath(@Nullable String setterArg) {
      this.dataPath = setterArg;
    }

    /**
     * The path to the folder where application assets are located. Resources whose protocol is `asset://`
     * will be fetched from an asset folder or asset management system provided by respective platform.
     * This option is ignored for Android platform. An iOS application may provide path to an application bundle's path.
     */
    private @Nullable String assetPath;

    public @Nullable String getAssetPath() {
      return assetPath;
    }

    public void setAssetPath(@Nullable String setterArg) {
      this.assetPath = setterArg;
    }

    /** The tile store usage mode. */
    private @Nullable TileStoreUsageMode tileStoreUsageMode;

    public @Nullable TileStoreUsageMode getTileStoreUsageMode() {
      return tileStoreUsageMode;
    }

    public void setTileStoreUsageMode(@Nullable TileStoreUsageMode setterArg) {
      this.tileStoreUsageMode = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    ResourceOptions() {}

    public static final class Builder {

      private @Nullable String accessToken;

      public @NonNull Builder setAccessToken(@NonNull String setterArg) {
        this.accessToken = setterArg;
        return this;
      }

      private @Nullable String baseURL;

      public @NonNull Builder setBaseURL(@Nullable String setterArg) {
        this.baseURL = setterArg;
        return this;
      }

      private @Nullable String dataPath;

      public @NonNull Builder setDataPath(@Nullable String setterArg) {
        this.dataPath = setterArg;
        return this;
      }

      private @Nullable String assetPath;

      public @NonNull Builder setAssetPath(@Nullable String setterArg) {
        this.assetPath = setterArg;
        return this;
      }

      private @Nullable TileStoreUsageMode tileStoreUsageMode;

      public @NonNull Builder setTileStoreUsageMode(@Nullable TileStoreUsageMode setterArg) {
        this.tileStoreUsageMode = setterArg;
        return this;
      }

      public @NonNull ResourceOptions build() {
        ResourceOptions pigeonReturn = new ResourceOptions();
        pigeonReturn.setAccessToken(accessToken);
        pigeonReturn.setBaseURL(baseURL);
        pigeonReturn.setDataPath(dataPath);
        pigeonReturn.setAssetPath(assetPath);
        pigeonReturn.setTileStoreUsageMode(tileStoreUsageMode);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(5);
      toListResult.add(accessToken);
      toListResult.add(baseURL);
      toListResult.add(dataPath);
      toListResult.add(assetPath);
      toListResult.add(tileStoreUsageMode == null ? null : tileStoreUsageMode.index);
      return toListResult;
    }

    static @NonNull ResourceOptions fromList(@NonNull ArrayList<Object> list) {
      ResourceOptions pigeonResult = new ResourceOptions();
      Object accessToken = list.get(0);
      pigeonResult.setAccessToken((String) accessToken);
      Object baseURL = list.get(1);
      pigeonResult.setBaseURL((String) baseURL);
      Object dataPath = list.get(2);
      pigeonResult.setDataPath((String) dataPath);
      Object assetPath = list.get(3);
      pigeonResult.setAssetPath((String) assetPath);
      Object tileStoreUsageMode = list.get(4);
      pigeonResult.setTileStoreUsageMode(tileStoreUsageMode == null ? null : TileStoreUsageMode.values()[(int) tileStoreUsageMode]);
      return pigeonResult;
    }
  }

  /**
   * The information about style object (source or layer).
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class StyleObjectInfo {
    /** The object's identifier. */
    private @NonNull String id;

    public @NonNull String getId() {
      return id;
    }

    public void setId(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"id\" is null.");
      }
      this.id = setterArg;
    }

    /** The object's type. */
    private @NonNull String type;

    public @NonNull String getType() {
      return type;
    }

    public void setType(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"type\" is null.");
      }
      this.type = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    StyleObjectInfo() {}

    public static final class Builder {

      private @Nullable String id;

      public @NonNull Builder setId(@NonNull String setterArg) {
        this.id = setterArg;
        return this;
      }

      private @Nullable String type;

      public @NonNull Builder setType(@NonNull String setterArg) {
        this.type = setterArg;
        return this;
      }

      public @NonNull StyleObjectInfo build() {
        StyleObjectInfo pigeonReturn = new StyleObjectInfo();
        pigeonReturn.setId(id);
        pigeonReturn.setType(type);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(id);
      toListResult.add(type);
      return toListResult;
    }

    static @NonNull StyleObjectInfo fromList(@NonNull ArrayList<Object> list) {
      StyleObjectInfo pigeonResult = new StyleObjectInfo();
      Object id = list.get(0);
      pigeonResult.setId((String) id);
      Object type = list.get(1);
      pigeonResult.setType((String) type);
      return pigeonResult;
    }
  }

  /**
   * Image type.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class MbxImage {
    /** The width of the image, in screen pixels. */
    private @NonNull Long width;

    public @NonNull Long getWidth() {
      return width;
    }

    public void setWidth(@NonNull Long setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"width\" is null.");
      }
      this.width = setterArg;
    }

    /** The height of the image, in screen pixels. */
    private @NonNull Long height;

    public @NonNull Long getHeight() {
      return height;
    }

    public void setHeight(@NonNull Long setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"height\" is null.");
      }
      this.height = setterArg;
    }

    /**
     * 32-bit premultiplied RGBA image data.
     *
     * An uncompressed image data encoded in 32-bit RGBA format with premultiplied
     * alpha channel. This field should contain exactly `4 * width * height` bytes. It
     * should consist of a sequence of scanlines.
     */
    private @NonNull byte[] data;

    public @NonNull byte[] getData() {
      return data;
    }

    public void setData(@NonNull byte[] setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"data\" is null.");
      }
      this.data = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    MbxImage() {}

    public static final class Builder {

      private @Nullable Long width;

      public @NonNull Builder setWidth(@NonNull Long setterArg) {
        this.width = setterArg;
        return this;
      }

      private @Nullable Long height;

      public @NonNull Builder setHeight(@NonNull Long setterArg) {
        this.height = setterArg;
        return this;
      }

      private @Nullable byte[] data;

      public @NonNull Builder setData(@NonNull byte[] setterArg) {
        this.data = setterArg;
        return this;
      }

      public @NonNull MbxImage build() {
        MbxImage pigeonReturn = new MbxImage();
        pigeonReturn.setWidth(width);
        pigeonReturn.setHeight(height);
        pigeonReturn.setData(data);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(3);
      toListResult.add(width);
      toListResult.add(height);
      toListResult.add(data);
      return toListResult;
    }

    static @NonNull MbxImage fromList(@NonNull ArrayList<Object> list) {
      MbxImage pigeonResult = new MbxImage();
      Object width = list.get(0);
      pigeonResult.setWidth((width == null) ? null : ((width instanceof Integer) ? (Integer) width : (Long) width));
      Object height = list.get(1);
      pigeonResult.setHeight((height == null) ? null : ((height instanceof Integer) ? (Integer) height : (Long) height));
      Object data = list.get(2);
      pigeonResult.setData((byte[]) data);
      return pigeonResult;
    }
  }

  /**
   * Describes the image stretch areas.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class ImageStretches {
    /** The first stretchable part in screen pixel units. */
    private @NonNull Double first;

    public @NonNull Double getFirst() {
      return first;
    }

    public void setFirst(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"first\" is null.");
      }
      this.first = setterArg;
    }

    /** The second stretchable part in screen pixel units. */
    private @NonNull Double second;

    public @NonNull Double getSecond() {
      return second;
    }

    public void setSecond(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"second\" is null.");
      }
      this.second = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    ImageStretches() {}

    public static final class Builder {

      private @Nullable Double first;

      public @NonNull Builder setFirst(@NonNull Double setterArg) {
        this.first = setterArg;
        return this;
      }

      private @Nullable Double second;

      public @NonNull Builder setSecond(@NonNull Double setterArg) {
        this.second = setterArg;
        return this;
      }

      public @NonNull ImageStretches build() {
        ImageStretches pigeonReturn = new ImageStretches();
        pigeonReturn.setFirst(first);
        pigeonReturn.setSecond(second);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(first);
      toListResult.add(second);
      return toListResult;
    }

    static @NonNull ImageStretches fromList(@NonNull ArrayList<Object> list) {
      ImageStretches pigeonResult = new ImageStretches();
      Object first = list.get(0);
      pigeonResult.setFirst((Double) first);
      Object second = list.get(1);
      pigeonResult.setSecond((Double) second);
      return pigeonResult;
    }
  }

  /**
   * Describes the image content, e.g. where text can be fit into an image.
   *
   * When sizing icons with `icon-text-fit`, the icon size will be adjusted so that the this content box fits exactly around the text.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class ImageContent {
    /** Distance to the left, in screen pixels. */
    private @NonNull Double left;

    public @NonNull Double getLeft() {
      return left;
    }

    public void setLeft(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"left\" is null.");
      }
      this.left = setterArg;
    }

    /** Distance to the top, in screen pixels. */
    private @NonNull Double top;

    public @NonNull Double getTop() {
      return top;
    }

    public void setTop(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"top\" is null.");
      }
      this.top = setterArg;
    }

    /** Distance to the right, in screen pixels. */
    private @NonNull Double right;

    public @NonNull Double getRight() {
      return right;
    }

    public void setRight(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"right\" is null.");
      }
      this.right = setterArg;
    }

    /** Distance to the bottom, in screen pixels. */
    private @NonNull Double bottom;

    public @NonNull Double getBottom() {
      return bottom;
    }

    public void setBottom(@NonNull Double setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"bottom\" is null.");
      }
      this.bottom = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    ImageContent() {}

    public static final class Builder {

      private @Nullable Double left;

      public @NonNull Builder setLeft(@NonNull Double setterArg) {
        this.left = setterArg;
        return this;
      }

      private @Nullable Double top;

      public @NonNull Builder setTop(@NonNull Double setterArg) {
        this.top = setterArg;
        return this;
      }

      private @Nullable Double right;

      public @NonNull Builder setRight(@NonNull Double setterArg) {
        this.right = setterArg;
        return this;
      }

      private @Nullable Double bottom;

      public @NonNull Builder setBottom(@NonNull Double setterArg) {
        this.bottom = setterArg;
        return this;
      }

      public @NonNull ImageContent build() {
        ImageContent pigeonReturn = new ImageContent();
        pigeonReturn.setLeft(left);
        pigeonReturn.setTop(top);
        pigeonReturn.setRight(right);
        pigeonReturn.setBottom(bottom);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(4);
      toListResult.add(left);
      toListResult.add(top);
      toListResult.add(right);
      toListResult.add(bottom);
      return toListResult;
    }

    static @NonNull ImageContent fromList(@NonNull ArrayList<Object> list) {
      ImageContent pigeonResult = new ImageContent();
      Object left = list.get(0);
      pigeonResult.setLeft((Double) left);
      Object top = list.get(1);
      pigeonResult.setTop((Double) top);
      Object right = list.get(2);
      pigeonResult.setRight((Double) right);
      Object bottom = list.get(3);
      pigeonResult.setBottom((Double) bottom);
      return pigeonResult;
    }
  }

  /**
   * The `transition options` controls timing for the interpolation between a transitionable style
   * property's previous value and new value. These can be used to define the style default property
   * transition behavior. Also, any transitionable style property may also have its own `-transition`
   * property that defines specific transition timing for that specific layer property, overriding
   * the global transition values.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class TransitionOptions {
    /** Time allotted for transitions to complete. Units in milliseconds. Defaults to `300.0`. */
    private @Nullable Long duration;

    public @Nullable Long getDuration() {
      return duration;
    }

    public void setDuration(@Nullable Long setterArg) {
      this.duration = setterArg;
    }

    /** Length of time before a transition begins. Units in milliseconds. Defaults to `0.0`. */
    private @Nullable Long delay;

    public @Nullable Long getDelay() {
      return delay;
    }

    public void setDelay(@Nullable Long setterArg) {
      this.delay = setterArg;
    }

    /** Whether the fade in/out symbol placement transition is enabled. Defaults to `true`. */
    private @Nullable Boolean enablePlacementTransitions;

    public @Nullable Boolean getEnablePlacementTransitions() {
      return enablePlacementTransitions;
    }

    public void setEnablePlacementTransitions(@Nullable Boolean setterArg) {
      this.enablePlacementTransitions = setterArg;
    }

    public static final class Builder {

      private @Nullable Long duration;

      public @NonNull Builder setDuration(@Nullable Long setterArg) {
        this.duration = setterArg;
        return this;
      }

      private @Nullable Long delay;

      public @NonNull Builder setDelay(@Nullable Long setterArg) {
        this.delay = setterArg;
        return this;
      }

      private @Nullable Boolean enablePlacementTransitions;

      public @NonNull Builder setEnablePlacementTransitions(@Nullable Boolean setterArg) {
        this.enablePlacementTransitions = setterArg;
        return this;
      }

      public @NonNull TransitionOptions build() {
        TransitionOptions pigeonReturn = new TransitionOptions();
        pigeonReturn.setDuration(duration);
        pigeonReturn.setDelay(delay);
        pigeonReturn.setEnablePlacementTransitions(enablePlacementTransitions);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(3);
      toListResult.add(duration);
      toListResult.add(delay);
      toListResult.add(enablePlacementTransitions);
      return toListResult;
    }

    static @NonNull TransitionOptions fromList(@NonNull ArrayList<Object> list) {
      TransitionOptions pigeonResult = new TransitionOptions();
      Object duration = list.get(0);
      pigeonResult.setDuration((duration == null) ? null : ((duration instanceof Integer) ? (Integer) duration : (Long) duration));
      Object delay = list.get(1);
      pigeonResult.setDelay((delay == null) ? null : ((delay instanceof Integer) ? (Integer) delay : (Long) delay));
      Object enablePlacementTransitions = list.get(2);
      pigeonResult.setEnablePlacementTransitions((Boolean) enablePlacementTransitions);
      return pigeonResult;
    }
  }

  /**
   * Represents a tile coordinate.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class CanonicalTileID {
    /** The z value of the coordinate (zoom-level). */
    private @NonNull Long z;

    public @NonNull Long getZ() {
      return z;
    }

    public void setZ(@NonNull Long setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"z\" is null.");
      }
      this.z = setterArg;
    }

    /** The x value of the coordinate. */
    private @NonNull Long x;

    public @NonNull Long getX() {
      return x;
    }

    public void setX(@NonNull Long setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"x\" is null.");
      }
      this.x = setterArg;
    }

    /** The y value of the coordinate. */
    private @NonNull Long y;

    public @NonNull Long getY() {
      return y;
    }

    public void setY(@NonNull Long setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"y\" is null.");
      }
      this.y = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    CanonicalTileID() {}

    public static final class Builder {

      private @Nullable Long z;

      public @NonNull Builder setZ(@NonNull Long setterArg) {
        this.z = setterArg;
        return this;
      }

      private @Nullable Long x;

      public @NonNull Builder setX(@NonNull Long setterArg) {
        this.x = setterArg;
        return this;
      }

      private @Nullable Long y;

      public @NonNull Builder setY(@NonNull Long setterArg) {
        this.y = setterArg;
        return this;
      }

      public @NonNull CanonicalTileID build() {
        CanonicalTileID pigeonReturn = new CanonicalTileID();
        pigeonReturn.setZ(z);
        pigeonReturn.setX(x);
        pigeonReturn.setY(y);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(3);
      toListResult.add(z);
      toListResult.add(x);
      toListResult.add(y);
      return toListResult;
    }

    static @NonNull CanonicalTileID fromList(@NonNull ArrayList<Object> list) {
      CanonicalTileID pigeonResult = new CanonicalTileID();
      Object z = list.get(0);
      pigeonResult.setZ((z == null) ? null : ((z instanceof Integer) ? (Integer) z : (Long) z));
      Object x = list.get(1);
      pigeonResult.setX((x == null) ? null : ((x instanceof Integer) ? (Integer) x : (Long) x));
      Object y = list.get(2);
      pigeonResult.setY((y == null) ? null : ((y instanceof Integer) ? (Integer) y : (Long) y));
      return pigeonResult;
    }
  }

  /**
   * Holds a style property value with meta data.
   *
   * Generated class from Pigeon that represents data sent in messages.
   */
  public static final class StylePropertyValue {
    /** The property value. */
    private @NonNull String value;

    public @NonNull String getValue() {
      return value;
    }

    public void setValue(@NonNull String setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"value\" is null.");
      }
      this.value = setterArg;
    }

    /** The kind of the property value. */
    private @NonNull StylePropertyValueKind kind;

    public @NonNull StylePropertyValueKind getKind() {
      return kind;
    }

    public void setKind(@NonNull StylePropertyValueKind setterArg) {
      if (setterArg == null) {
        throw new IllegalStateException("Nonnull field \"kind\" is null.");
      }
      this.kind = setterArg;
    }

    /** Constructor is non-public to enforce null safety; use Builder. */
    StylePropertyValue() {}

    public static final class Builder {

      private @Nullable String value;

      public @NonNull Builder setValue(@NonNull String setterArg) {
        this.value = setterArg;
        return this;
      }

      private @Nullable StylePropertyValueKind kind;

      public @NonNull Builder setKind(@NonNull StylePropertyValueKind setterArg) {
        this.kind = setterArg;
        return this;
      }

      public @NonNull StylePropertyValue build() {
        StylePropertyValue pigeonReturn = new StylePropertyValue();
        pigeonReturn.setValue(value);
        pigeonReturn.setKind(kind);
        return pigeonReturn;
      }
    }

    @NonNull
    ArrayList<Object> toList() {
      ArrayList<Object> toListResult = new ArrayList<Object>(2);
      toListResult.add(value);
      toListResult.add(kind == null ? null : kind.index);
      return toListResult;
    }

    static @NonNull StylePropertyValue fromList(@NonNull ArrayList<Object> list) {
      StylePropertyValue pigeonResult = new StylePropertyValue();
      Object value = list.get(0);
      pigeonResult.setValue((String) value);
      Object kind = list.get(1);
      pigeonResult.setKind(StylePropertyValueKind.values()[(int) kind]);
      return pigeonResult;
    }
  }

  public interface Result<T> {
    @SuppressWarnings("UnknownNullness")
    void success(T result);

    void error(@NonNull Throwable error);
  }

  private static class _AnimationManagerCodec extends StandardMessageCodec {
    public static final _AnimationManagerCodec INSTANCE = new _AnimationManagerCodec();

    private _AnimationManagerCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return CameraOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 129:
          return MapAnimationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 130:
          return MbxEdgeInsets.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 131:
          return ScreenCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 132:
          return ScreenCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof CameraOptions) {
        stream.write(128);
        writeValue(stream, ((CameraOptions) value).toList());
      } else if (value instanceof MapAnimationOptions) {
        stream.write(129);
        writeValue(stream, ((MapAnimationOptions) value).toList());
      } else if (value instanceof MbxEdgeInsets) {
        stream.write(130);
        writeValue(stream, ((MbxEdgeInsets) value).toList());
      } else if (value instanceof ScreenCoordinate) {
        stream.write(131);
        writeValue(stream, ((ScreenCoordinate) value).toList());
      } else if (value instanceof ScreenCoordinate) {
        stream.write(132);
        writeValue(stream, ((ScreenCoordinate) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /**
   * Interface for managing animation.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface _AnimationManager {

    void easeTo(@NonNull CameraOptions cameraOptions, @Nullable MapAnimationOptions mapAnimationOptions);

    void flyTo(@NonNull CameraOptions cameraOptions, @Nullable MapAnimationOptions mapAnimationOptions);

    void pitchBy(@NonNull Double pitch, @Nullable MapAnimationOptions mapAnimationOptions);

    void scaleBy(@NonNull Double amount, @Nullable ScreenCoordinate screenCoordinate, @Nullable MapAnimationOptions mapAnimationOptions);

    void moveBy(@NonNull ScreenCoordinate screenCoordinate, @Nullable MapAnimationOptions mapAnimationOptions);

    void rotateBy(@NonNull ScreenCoordinate first, @NonNull ScreenCoordinate second, @Nullable MapAnimationOptions mapAnimationOptions);

    void cancelCameraAnimation();

    /** The codec used by _AnimationManager. */
    static @NonNull MessageCodec<Object> getCodec() {
      return _AnimationManagerCodec.INSTANCE;
    }
    /**Sets up an instance of `_AnimationManager` to handle messages through the `binaryMessenger`. */
    static void setup(@NonNull BinaryMessenger binaryMessenger, @Nullable _AnimationManager api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.easeTo", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                CameraOptions cameraOptionsArg = (CameraOptions) args.get(0);
                MapAnimationOptions mapAnimationOptionsArg = (MapAnimationOptions) args.get(1);
                try {
                  api.easeTo(cameraOptionsArg, mapAnimationOptionsArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.flyTo", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                CameraOptions cameraOptionsArg = (CameraOptions) args.get(0);
                MapAnimationOptions mapAnimationOptionsArg = (MapAnimationOptions) args.get(1);
                try {
                  api.flyTo(cameraOptionsArg, mapAnimationOptionsArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.pitchBy", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Double pitchArg = (Double) args.get(0);
                MapAnimationOptions mapAnimationOptionsArg = (MapAnimationOptions) args.get(1);
                try {
                  api.pitchBy(pitchArg, mapAnimationOptionsArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.scaleBy", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Double amountArg = (Double) args.get(0);
                ScreenCoordinate screenCoordinateArg = (ScreenCoordinate) args.get(1);
                MapAnimationOptions mapAnimationOptionsArg = (MapAnimationOptions) args.get(2);
                try {
                  api.scaleBy(amountArg, screenCoordinateArg, mapAnimationOptionsArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.moveBy", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                ScreenCoordinate screenCoordinateArg = (ScreenCoordinate) args.get(0);
                MapAnimationOptions mapAnimationOptionsArg = (MapAnimationOptions) args.get(1);
                try {
                  api.moveBy(screenCoordinateArg, mapAnimationOptionsArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.rotateBy", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                ScreenCoordinate firstArg = (ScreenCoordinate) args.get(0);
                ScreenCoordinate secondArg = (ScreenCoordinate) args.get(1);
                MapAnimationOptions mapAnimationOptionsArg = (MapAnimationOptions) args.get(2);
                try {
                  api.rotateBy(firstArg, secondArg, mapAnimationOptionsArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._AnimationManager.cancelCameraAnimation", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  api.cancelCameraAnimation();
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }

  private static class _CameraManagerCodec extends StandardMessageCodec {
    public static final _CameraManagerCodec INSTANCE = new _CameraManagerCodec();

    private _CameraManagerCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return CameraBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 129:
          return CameraBoundsOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 130:
          return CameraOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 131:
          return CameraState.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 132:
          return CanonicalTileID.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 133:
          return CoordinateBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 134:
          return CoordinateBoundsZoom.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 135:
          return FeatureExtensionValue.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 136:
          return GlyphsRasterizationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 137:
          return ImageContent.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 138:
          return ImageStretches.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 139:
          return LayerPosition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 140:
          return MapAnimationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 141:
          return MapDebugOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 142:
          return MapMemoryBudgetInMegabytes.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 143:
          return MapMemoryBudgetInTiles.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 144:
          return MapOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 145:
          return MbxEdgeInsets.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 146:
          return MbxImage.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 147:
          return MercatorCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 148:
          return OfflineRegionGeometryDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 149:
          return OfflineRegionTilePyramidDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 150:
          return ProjectedMeters.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 151:
          return QueriedFeature.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 152:
          return RenderedQueryGeometry.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 153:
          return RenderedQueryOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 154:
          return ResourceOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 155:
          return ScreenBox.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 156:
          return ScreenCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 157:
          return Size.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 158:
          return SourceQueryOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 159:
          return StyleObjectInfo.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 160:
          return StylePropertyValue.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 161:
          return TransitionOptions.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof CameraBounds) {
        stream.write(128);
        writeValue(stream, ((CameraBounds) value).toList());
      } else if (value instanceof CameraBoundsOptions) {
        stream.write(129);
        writeValue(stream, ((CameraBoundsOptions) value).toList());
      } else if (value instanceof CameraOptions) {
        stream.write(130);
        writeValue(stream, ((CameraOptions) value).toList());
      } else if (value instanceof CameraState) {
        stream.write(131);
        writeValue(stream, ((CameraState) value).toList());
      } else if (value instanceof CanonicalTileID) {
        stream.write(132);
        writeValue(stream, ((CanonicalTileID) value).toList());
      } else if (value instanceof CoordinateBounds) {
        stream.write(133);
        writeValue(stream, ((CoordinateBounds) value).toList());
      } else if (value instanceof CoordinateBoundsZoom) {
        stream.write(134);
        writeValue(stream, ((CoordinateBoundsZoom) value).toList());
      } else if (value instanceof FeatureExtensionValue) {
        stream.write(135);
        writeValue(stream, ((FeatureExtensionValue) value).toList());
      } else if (value instanceof GlyphsRasterizationOptions) {
        stream.write(136);
        writeValue(stream, ((GlyphsRasterizationOptions) value).toList());
      } else if (value instanceof ImageContent) {
        stream.write(137);
        writeValue(stream, ((ImageContent) value).toList());
      } else if (value instanceof ImageStretches) {
        stream.write(138);
        writeValue(stream, ((ImageStretches) value).toList());
      } else if (value instanceof LayerPosition) {
        stream.write(139);
        writeValue(stream, ((LayerPosition) value).toList());
      } else if (value instanceof MapAnimationOptions) {
        stream.write(140);
        writeValue(stream, ((MapAnimationOptions) value).toList());
      } else if (value instanceof MapDebugOptions) {
        stream.write(141);
        writeValue(stream, ((MapDebugOptions) value).toList());
      } else if (value instanceof MapMemoryBudgetInMegabytes) {
        stream.write(142);
        writeValue(stream, ((MapMemoryBudgetInMegabytes) value).toList());
      } else if (value instanceof MapMemoryBudgetInTiles) {
        stream.write(143);
        writeValue(stream, ((MapMemoryBudgetInTiles) value).toList());
      } else if (value instanceof MapOptions) {
        stream.write(144);
        writeValue(stream, ((MapOptions) value).toList());
      } else if (value instanceof MbxEdgeInsets) {
        stream.write(145);
        writeValue(stream, ((MbxEdgeInsets) value).toList());
      } else if (value instanceof MbxImage) {
        stream.write(146);
        writeValue(stream, ((MbxImage) value).toList());
      } else if (value instanceof MercatorCoordinate) {
        stream.write(147);
        writeValue(stream, ((MercatorCoordinate) value).toList());
      } else if (value instanceof OfflineRegionGeometryDefinition) {
        stream.write(148);
        writeValue(stream, ((OfflineRegionGeometryDefinition) value).toList());
      } else if (value instanceof OfflineRegionTilePyramidDefinition) {
        stream.write(149);
        writeValue(stream, ((OfflineRegionTilePyramidDefinition) value).toList());
      } else if (value instanceof ProjectedMeters) {
        stream.write(150);
        writeValue(stream, ((ProjectedMeters) value).toList());
      } else if (value instanceof QueriedFeature) {
        stream.write(151);
        writeValue(stream, ((QueriedFeature) value).toList());
      } else if (value instanceof RenderedQueryGeometry) {
        stream.write(152);
        writeValue(stream, ((RenderedQueryGeometry) value).toList());
      } else if (value instanceof RenderedQueryOptions) {
        stream.write(153);
        writeValue(stream, ((RenderedQueryOptions) value).toList());
      } else if (value instanceof ResourceOptions) {
        stream.write(154);
        writeValue(stream, ((ResourceOptions) value).toList());
      } else if (value instanceof ScreenBox) {
        stream.write(155);
        writeValue(stream, ((ScreenBox) value).toList());
      } else if (value instanceof ScreenCoordinate) {
        stream.write(156);
        writeValue(stream, ((ScreenCoordinate) value).toList());
      } else if (value instanceof Size) {
        stream.write(157);
        writeValue(stream, ((Size) value).toList());
      } else if (value instanceof SourceQueryOptions) {
        stream.write(158);
        writeValue(stream, ((SourceQueryOptions) value).toList());
      } else if (value instanceof StyleObjectInfo) {
        stream.write(159);
        writeValue(stream, ((StyleObjectInfo) value).toList());
      } else if (value instanceof StylePropertyValue) {
        stream.write(160);
        writeValue(stream, ((StylePropertyValue) value).toList());
      } else if (value instanceof TransitionOptions) {
        stream.write(161);
        writeValue(stream, ((TransitionOptions) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /**
   * Interface for managing camera.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface _CameraManager {
    /**
     * Convenience method that returns the `camera options` object for given parameters.
     *
     * @param bounds The `coordinate bounds` of the camera.
     * @param padding The `edge insets` of the camera.
     * @param bearing The bearing of the camera.
     * @param pitch The pitch of the camera.
     *
     * @return The `camera options` object representing the provided parameters.
     */
    @NonNull 
    CameraOptions cameraForCoordinateBounds(@NonNull CoordinateBounds bounds, @NonNull MbxEdgeInsets padding, @Nullable Double bearing, @Nullable Double pitch);
    /**
     * Convenience method that returns the `camera options` object for given parameters.
     *
     * @param coordinates The `coordinates` representing the bounds of the camera.
     * @param padding The `edge insets` of the camera.
     * @param bearing The bearing of the camera.
     * @param pitch The pitch of the camera.
     *
     * @return The `camera options` object representing the provided parameters.
     */
    @NonNull 
    CameraOptions cameraForCoordinates(@NonNull List<Map<String, Object>> coordinates, @NonNull MbxEdgeInsets padding, @Nullable Double bearing, @Nullable Double pitch);
    /**
     * Convenience method that adjusts the provided `camera options` object for given parameters.
     *
     * Returns the provided `camera` options with zoom adjusted to fit `coordinates` into the `box`, so that `coordinates` on the left,
     * top and right of the effective `camera` center at the principal point of the projection (defined by `padding`) fit into the `box`.
     * Returns the provided `camera` options object unchanged upon an error.
     * Note that this method may fail if the principal point of the projection is not inside the `box` or
     * if there is no sufficient screen space, defined by principal point and the `box`, to fit the geometry.
     *
     * @param coordinates The `coordinates` representing the bounds of the camera.
     * @param camera The `camera options` for which zoom should be adjusted. Note that the `camera.center` is required.
     * @param box The `screen box` into which `coordinates` should fit.
     *
     * @return The `camera options` object with the zoom level adjusted to fit `coordinates` into the `box`.
     */
    @NonNull 
    CameraOptions cameraForCoordinatesCameraOptions(@NonNull List<Map<String, Object>> coordinates, @NonNull CameraOptions camera, @NonNull ScreenBox box);
    /**
     * Convenience method that returns the `camera options` object for given parameters.
     *
     * @param geometry The `geometry` representing the bounds of the camera.
     * @param padding The `edge insets` of the camera.
     * @param bearing The bearing of the camera.
     * @param pitch The pitch of the camera.
     *
     * @return The `camera options` object representing the provided parameters.
     */
    @NonNull 
    CameraOptions cameraForGeometry(@NonNull Map<String, Object> geometry, @NonNull MbxEdgeInsets padding, @Nullable Double bearing, @Nullable Double pitch);
    /**
     * Returns the `coordinate bounds` for a given camera.
     *
     * Note that if the given `camera` shows the antimeridian, the returned wrapped `coordinate bounds`
     * might not represent the minimum bounding box.
     *
     * @param camera The `camera options` to use for calculating `coordinate bounds`.
     *
     * @return The `coordinate bounds` object representing a given `camera`.
     *
     */
    @NonNull 
    CoordinateBounds coordinateBoundsForCamera(@NonNull CameraOptions camera);
    /**
     * Returns the `coordinate bounds` for a given camera.
     *
     * This method is useful if the `camera` shows the antimeridian.
     *
     * @param camera The `camera options` to use for calculating `coordinate bounds`.
     *
     * @return The `coordinate bounds` object representing a given `camera`.
     *
     */
    @NonNull 
    CoordinateBounds coordinateBoundsForCameraUnwrapped(@NonNull CameraOptions camera);
    /**
     * Returns the `coordinate bounds` and the `zoom` for a given `camera`.
     *
     * Note that if the given `camera` shows the antimeridian, the returned wrapped `coordinate bounds`
     * might not represent the minimum bounding box.
     *
     * @param camera The `camera options` to use for calculating `coordinate bounds` and `zoom`.
     *
     * @return The object representing `coordinate bounds` and `zoom` for a given `camera`.
     *
     */
    @NonNull 
    CoordinateBoundsZoom coordinateBoundsZoomForCamera(@NonNull CameraOptions camera);
    /**
     * Returns the unwrapped `coordinate bounds` and `zoom` for a given `camera`.
     *
     * This method is useful if the `camera` shows the antimeridian.
     *
     * @param camera The `camera options` to use for calculating `coordinate bounds` and `zoom`.
     *
     * @return The object representing `coordinate bounds` and `zoom` for a given `camera`.
     *
     */
    @NonNull 
    CoordinateBoundsZoom coordinateBoundsZoomForCameraUnwrapped(@NonNull CameraOptions camera);
    /**
     * Calculates a `screen coordinate` that corresponds to a geographical coordinate
     * (i.e., longitude-latitude pair).
     *
     * The `screen coordinate` is in `platform pixels` relative to the top left corner
     * of the map (not of the whole screen).
     *
     * @param coordinate A geographical `coordinate` on the map to convert to a `screen coordinate`.
     *
     * @return A `screen coordinate` on the screen in `platform pixels`.
     */
    @NonNull 
    ScreenCoordinate pixelForCoordinate(@NonNull Map<String, Object> coordinate);
    /**
     * Calculates a geographical `coordinate` (i.e., longitude-latitude pair) that corresponds
     * to a `screen coordinate`.
     *
     * The screen coordinate is in `platform pixels`relative to the top left corner
     * of the map (not of the whole screen).
     *
     * @param pixel A `screen coordinate` on the screen in `platform pixels`.
     *
     * @return A geographical `coordinate` corresponding to a given `screen coordinate`.
     */
    @NonNull 
    Map<String, Object> coordinateForPixel(@NonNull ScreenCoordinate pixel);
    /**
     * Calculates `screen coordinates` that correspond to geographical `coordinates`
     * (i.e., longitude-latitude pairs).
     *
     * The `screen coordinates` are in `platform pixels` relative to the top left corner
     * of the map (not of the whole screen).
     *
     * @param coordinates A geographical `coordinates` on the map to convert to `screen coordinates`.
     *
     * @return A `screen coordinates` in `platform pixels` for a given geographical `coordinates`.
     */
    @NonNull 
    List<ScreenCoordinate> pixelsForCoordinates(@NonNull List<Map<String, Object>> coordinates);
    /**
     * Calculates geographical `coordinates` (i.e., longitude-latitude pairs) that correspond
     * to `screen coordinates`.
     *
     * The screen coordinates are in `platform pixels` relative to the top left corner
     * of the map (not of the whole screen).
     *
     * @param pixels A `screen coordinates` in `platform pixels`.
     *
     * @return A `geographical coordinates` that correspond to a given `screen coordinates`.
     */
    @NonNull 
    List<Map<String, Object>> coordinatesForPixels(@NonNull List<ScreenCoordinate> pixels);
    /**
     * Changes the map view by any combination of center, zoom, bearing, and pitch, without an animated transition.
     * The map will retain its current values for any details not passed via the camera options argument.
     * It is not guaranteed that the provided `camera options` will be set, the map may apply constraints resulting in a
     * different `camera state`.
     *
     * @param cameraOptions The new `camera options` to be set.
     */
    void setCamera(@NonNull CameraOptions cameraOptions);
    /**
     * Returns the current `camera state`.
     *
     * @return The current `camera state`.
     */
    @NonNull 
    CameraState getCameraState();
    /**
     * Sets the `camera bounds options` of the map. The map will retain its current values for any
     * details not passed via the camera bounds options arguments.
     * When camera bounds options are set, the camera center is constrained by these bounds, as well as the minimum
     * zoom level of the camera, to prevent out of bounds areas to be visible.
     * Note that tilting or rotating the map, or setting stricter minimum and maximum zoom within `options` may still cause some out of bounds areas to become visible.
     *
     * @param options The `camera bounds options` to set.
     * @return A string describing an error if the operation was not successful, expected with `void` value otherwise.
     */
    void setBounds(@NonNull CameraBoundsOptions options);
    /**
     * Returns the `camera bounds` of the map.
     * @return A `camera bounds` of the map.
     */
    @NonNull 
    CameraBounds getBounds();
    /**
     * Prepares the drag gesture to use the provided screen coordinate as a pivot `point`. This function should be called each time when user starts a dragging action (e.g. by clicking on the map). The following dragging will be relative to the pivot.
     *
     * @param point The pivot `screen coordinate`, measured in `platform pixels` from top to bottom and from left to right.
     */
    void dragStart(@NonNull ScreenCoordinate point);
    /**
     * Calculates target point where camera should move after drag. The method should be called after `dragStart` and before `dragEnd`.
     *
     * @param fromPoint The `screen coordinate` to drag the map from, measured in `platform pixels` from top to bottom and from left to right.
     * @param toPoint The `screen coordinate` to drag the map to, measured in `platform pixels` from top to bottom and from left to right.
     *
     * @return The `camera options` object showing the end point.
     */
    @NonNull 
    CameraOptions getDragCameraOptions(@NonNull ScreenCoordinate fromPoint, @NonNull ScreenCoordinate toPoint);
    /** Ends the ongoing drag gesture. This function should be called always after the user has ended a drag gesture initiated by `dragStart`. */
    void dragEnd();

    /** The codec used by _CameraManager. */
    static @NonNull MessageCodec<Object> getCodec() {
      return _CameraManagerCodec.INSTANCE;
    }
    /**Sets up an instance of `_CameraManager` to handle messages through the `binaryMessenger`. */
    static void setup(@NonNull BinaryMessenger binaryMessenger, @Nullable _CameraManager api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinateBounds", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                CoordinateBounds boundsArg = (CoordinateBounds) args.get(0);
                MbxEdgeInsets paddingArg = (MbxEdgeInsets) args.get(1);
                Double bearingArg = (Double) args.get(2);
                Double pitchArg = (Double) args.get(3);
                try {
                  CameraOptions output = api.cameraForCoordinateBounds(boundsArg, paddingArg, bearingArg, pitchArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinates", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                List<Map<String, Object>> coordinatesArg = (List<Map<String, Object>>) args.get(0);
                MbxEdgeInsets paddingArg = (MbxEdgeInsets) args.get(1);
                Double bearingArg = (Double) args.get(2);
                Double pitchArg = (Double) args.get(3);
                try {
                  CameraOptions output = api.cameraForCoordinates(coordinatesArg, paddingArg, bearingArg, pitchArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForCoordinatesCameraOptions", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                List<Map<String, Object>> coordinatesArg = (List<Map<String, Object>>) args.get(0);
                CameraOptions cameraArg = (CameraOptions) args.get(1);
                ScreenBox boxArg = (ScreenBox) args.get(2);
                try {
                  CameraOptions output = api.cameraForCoordinatesCameraOptions(coordinatesArg, cameraArg, boxArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.cameraForGeometry", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Map<String, Object> geometryArg = (Map<String, Object>) args.get(0);
                MbxEdgeInsets paddingArg = (MbxEdgeInsets) args.get(1);
                Double bearingArg = (Double) args.get(2);
                Double pitchArg = (Double) args.get(3);
                try {
                  CameraOptions output = api.cameraForGeometry(geometryArg, paddingArg, bearingArg, pitchArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsForCamera", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                CameraOptions cameraArg = (CameraOptions) args.get(0);
                try {
                  CoordinateBounds output = api.coordinateBoundsForCamera(cameraArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsForCameraUnwrapped", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                CameraOptions cameraArg = (CameraOptions) args.get(0);
                try {
                  CoordinateBounds output = api.coordinateBoundsForCameraUnwrapped(cameraArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsZoomForCamera", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                CameraOptions cameraArg = (CameraOptions) args.get(0);
                try {
                  CoordinateBoundsZoom output = api.coordinateBoundsZoomForCamera(cameraArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateBoundsZoomForCameraUnwrapped", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                CameraOptions cameraArg = (CameraOptions) args.get(0);
                try {
                  CoordinateBoundsZoom output = api.coordinateBoundsZoomForCameraUnwrapped(cameraArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.pixelForCoordinate", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Map<String, Object> coordinateArg = (Map<String, Object>) args.get(0);
                try {
                  ScreenCoordinate output = api.pixelForCoordinate(coordinateArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinateForPixel", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                ScreenCoordinate pixelArg = (ScreenCoordinate) args.get(0);
                try {
                  Map<String, Object> output = api.coordinateForPixel(pixelArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.pixelsForCoordinates", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                List<Map<String, Object>> coordinatesArg = (List<Map<String, Object>>) args.get(0);
                try {
                  List<ScreenCoordinate> output = api.pixelsForCoordinates(coordinatesArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.coordinatesForPixels", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                List<ScreenCoordinate> pixelsArg = (List<ScreenCoordinate>) args.get(0);
                try {
                  List<Map<String, Object>> output = api.coordinatesForPixels(pixelsArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.setCamera", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                CameraOptions cameraOptionsArg = (CameraOptions) args.get(0);
                try {
                  api.setCamera(cameraOptionsArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.getCameraState", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  CameraState output = api.getCameraState();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.setBounds", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                CameraBoundsOptions optionsArg = (CameraBoundsOptions) args.get(0);
                try {
                  api.setBounds(optionsArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.getBounds", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  CameraBounds output = api.getBounds();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.dragStart", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                ScreenCoordinate pointArg = (ScreenCoordinate) args.get(0);
                try {
                  api.dragStart(pointArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.getDragCameraOptions", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                ScreenCoordinate fromPointArg = (ScreenCoordinate) args.get(0);
                ScreenCoordinate toPointArg = (ScreenCoordinate) args.get(1);
                try {
                  CameraOptions output = api.getDragCameraOptions(fromPointArg, toPointArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._CameraManager.dragEnd", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  api.dragEnd();
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }

  private static class _MapInterfaceCodec extends StandardMessageCodec {
    public static final _MapInterfaceCodec INSTANCE = new _MapInterfaceCodec();

    private _MapInterfaceCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return CameraBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 129:
          return CameraBoundsOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 130:
          return CameraOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 131:
          return CameraState.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 132:
          return CanonicalTileID.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 133:
          return CoordinateBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 134:
          return CoordinateBoundsZoom.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 135:
          return FeatureExtensionValue.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 136:
          return GlyphsRasterizationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 137:
          return ImageContent.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 138:
          return ImageStretches.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 139:
          return LayerPosition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 140:
          return MapAnimationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 141:
          return MapDebugOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 142:
          return MapMemoryBudgetInMegabytes.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 143:
          return MapMemoryBudgetInTiles.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 144:
          return MapOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 145:
          return MbxEdgeInsets.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 146:
          return MbxImage.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 147:
          return MercatorCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 148:
          return OfflineRegionGeometryDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 149:
          return OfflineRegionTilePyramidDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 150:
          return ProjectedMeters.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 151:
          return QueriedFeature.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 152:
          return RenderedQueryGeometry.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 153:
          return RenderedQueryOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 154:
          return ResourceOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 155:
          return ScreenBox.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 156:
          return ScreenCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 157:
          return Size.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 158:
          return SourceQueryOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 159:
          return StyleObjectInfo.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 160:
          return StylePropertyValue.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 161:
          return TransitionOptions.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof CameraBounds) {
        stream.write(128);
        writeValue(stream, ((CameraBounds) value).toList());
      } else if (value instanceof CameraBoundsOptions) {
        stream.write(129);
        writeValue(stream, ((CameraBoundsOptions) value).toList());
      } else if (value instanceof CameraOptions) {
        stream.write(130);
        writeValue(stream, ((CameraOptions) value).toList());
      } else if (value instanceof CameraState) {
        stream.write(131);
        writeValue(stream, ((CameraState) value).toList());
      } else if (value instanceof CanonicalTileID) {
        stream.write(132);
        writeValue(stream, ((CanonicalTileID) value).toList());
      } else if (value instanceof CoordinateBounds) {
        stream.write(133);
        writeValue(stream, ((CoordinateBounds) value).toList());
      } else if (value instanceof CoordinateBoundsZoom) {
        stream.write(134);
        writeValue(stream, ((CoordinateBoundsZoom) value).toList());
      } else if (value instanceof FeatureExtensionValue) {
        stream.write(135);
        writeValue(stream, ((FeatureExtensionValue) value).toList());
      } else if (value instanceof GlyphsRasterizationOptions) {
        stream.write(136);
        writeValue(stream, ((GlyphsRasterizationOptions) value).toList());
      } else if (value instanceof ImageContent) {
        stream.write(137);
        writeValue(stream, ((ImageContent) value).toList());
      } else if (value instanceof ImageStretches) {
        stream.write(138);
        writeValue(stream, ((ImageStretches) value).toList());
      } else if (value instanceof LayerPosition) {
        stream.write(139);
        writeValue(stream, ((LayerPosition) value).toList());
      } else if (value instanceof MapAnimationOptions) {
        stream.write(140);
        writeValue(stream, ((MapAnimationOptions) value).toList());
      } else if (value instanceof MapDebugOptions) {
        stream.write(141);
        writeValue(stream, ((MapDebugOptions) value).toList());
      } else if (value instanceof MapMemoryBudgetInMegabytes) {
        stream.write(142);
        writeValue(stream, ((MapMemoryBudgetInMegabytes) value).toList());
      } else if (value instanceof MapMemoryBudgetInTiles) {
        stream.write(143);
        writeValue(stream, ((MapMemoryBudgetInTiles) value).toList());
      } else if (value instanceof MapOptions) {
        stream.write(144);
        writeValue(stream, ((MapOptions) value).toList());
      } else if (value instanceof MbxEdgeInsets) {
        stream.write(145);
        writeValue(stream, ((MbxEdgeInsets) value).toList());
      } else if (value instanceof MbxImage) {
        stream.write(146);
        writeValue(stream, ((MbxImage) value).toList());
      } else if (value instanceof MercatorCoordinate) {
        stream.write(147);
        writeValue(stream, ((MercatorCoordinate) value).toList());
      } else if (value instanceof OfflineRegionGeometryDefinition) {
        stream.write(148);
        writeValue(stream, ((OfflineRegionGeometryDefinition) value).toList());
      } else if (value instanceof OfflineRegionTilePyramidDefinition) {
        stream.write(149);
        writeValue(stream, ((OfflineRegionTilePyramidDefinition) value).toList());
      } else if (value instanceof ProjectedMeters) {
        stream.write(150);
        writeValue(stream, ((ProjectedMeters) value).toList());
      } else if (value instanceof QueriedFeature) {
        stream.write(151);
        writeValue(stream, ((QueriedFeature) value).toList());
      } else if (value instanceof RenderedQueryGeometry) {
        stream.write(152);
        writeValue(stream, ((RenderedQueryGeometry) value).toList());
      } else if (value instanceof RenderedQueryOptions) {
        stream.write(153);
        writeValue(stream, ((RenderedQueryOptions) value).toList());
      } else if (value instanceof ResourceOptions) {
        stream.write(154);
        writeValue(stream, ((ResourceOptions) value).toList());
      } else if (value instanceof ScreenBox) {
        stream.write(155);
        writeValue(stream, ((ScreenBox) value).toList());
      } else if (value instanceof ScreenCoordinate) {
        stream.write(156);
        writeValue(stream, ((ScreenCoordinate) value).toList());
      } else if (value instanceof Size) {
        stream.write(157);
        writeValue(stream, ((Size) value).toList());
      } else if (value instanceof SourceQueryOptions) {
        stream.write(158);
        writeValue(stream, ((SourceQueryOptions) value).toList());
      } else if (value instanceof StyleObjectInfo) {
        stream.write(159);
        writeValue(stream, ((StyleObjectInfo) value).toList());
      } else if (value instanceof StylePropertyValue) {
        stream.write(160);
        writeValue(stream, ((StylePropertyValue) value).toList());
      } else if (value instanceof TransitionOptions) {
        stream.write(161);
        writeValue(stream, ((TransitionOptions) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /**
   * Map class provides map rendering functionality.
   *
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface _MapInterface {

    void loadStyleURI(@NonNull String styleURI, @NonNull Result<Void> result);

    void loadStyleJson(@NonNull String styleJson, @NonNull Result<Void> result);

    void clearData(@NonNull Result<Void> result);

    void setMemoryBudget(@Nullable MapMemoryBudgetInMegabytes mapMemoryBudgetInMegabytes, @Nullable MapMemoryBudgetInTiles mapMemoryBudgetInTiles);
    /**
     * Gets the size of the map.
     *
     * @return The `size` of the map in `platform pixels`.
     */
    @NonNull 
    Size getSize();
    /** Triggers a repaint of the map. */
    void triggerRepaint();
    /**
     * Tells the map rendering engine that there is currently a gesture in progress. This
     * affects how the map renders labels, as it will use different texture filters if a gesture
     * is ongoing.
     *
     * @param inProgress The `boolean` value representing if a gesture is in progress.
     */
    void setGestureInProgress(@NonNull Boolean inProgress);
    /**
     * Returns `true` if a gesture is currently in progress.
     *
     * @return `true` if a gesture is currently in progress, `false` otherwise.
     */
    @NonNull 
    Boolean isGestureInProgress();
    /**
     * Tells the map rendering engine that the animation is currently performed by the
     * user (e.g. with a `setCamera` calls series). It adjusts the engine for the animation use case.
     * In particular, it brings more stability to symbol placement and rendering.
     *
     * @param inProgress The `boolean` value representing if user animation is in progress
     */
    void setUserAnimationInProgress(@NonNull Boolean inProgress);
    /**
     * Returns `true` if user animation is currently in progress.
     *
     * @return `true` if a user animation is currently in progress, `false` otherwise.
     */
    @NonNull 
    Boolean isUserAnimationInProgress();
    /**
     * When loading a map, if prefetch zoom `delta` is set to any number greater than 0,
     * the map will first request a tile at zoom level lower than `zoom - delta`, with requested
     * zoom level a multiple of `delta`, in an attempt to display a full map at lower resolution as quick as possible.
     *
     * @param delta The new prefetch zoom delta.
     */
    void setPrefetchZoomDelta(@NonNull Long delta);
    /**
     * Returns the map's prefetch zoom delta.
     *
     * @return The map's prefetch zoom `delta`.
     */
    @NonNull 
    Long getPrefetchZoomDelta();
    /** Sets the north `orientation mode`. */
    void setNorthOrientation(@NonNull NorthOrientation orientation);
    /** Sets the map `constrain mode`. */
    void setConstrainMode(@NonNull ConstrainMode mode);
    /** Sets the `viewport mode`. */
    void setViewportMode(@NonNull ViewportMode mode);
    /**
     * Returns the `map options`.
     *
     * @return The map's `map options`.
     */
    @NonNull 
    MapOptions getMapOptions();
    /**
     * Returns the `map debug options`.
     *
     * @return An array of `map debug options` flags currently set to the map.
     */
    @NonNull 
    List<MapDebugOptions> getDebug();
    /**
     * Sets the `map debug options` and enables debug mode based on the passed value.
     *
     * @param debugOptions An array of `map debug options` to be set.
     * @param value A `boolean` value representing the state for a given `map debug options`.
     *
     */
    void setDebug(@NonNull List<MapDebugOptions> debugOptions, @NonNull Boolean value);
    /**
     * Queries the map for rendered features.
     *
     * @param geometry The `screen pixel coordinates` (point, line string or box) to query for rendered features.
     * @param options The `render query options` for querying rendered features.
     * @return A `cancelable` object that could be used to cancel the pending query.
     */
    void queryRenderedFeatures(@NonNull RenderedQueryGeometry geometry, @NonNull RenderedQueryOptions options, @NonNull Result<List<QueriedFeature>> result);
    /**
     * Queries the map for source features.
     *
     * @param sourceId The style source identifier used to query for source features.
     * @param options The `source query options` for querying source features.
     */
    void querySourceFeatures(@NonNull String sourceId, @NonNull SourceQueryOptions options, @NonNull Result<List<QueriedFeature>> result);
    /**
     * Returns all the leaves (original points) of a cluster (given its cluster_id) from a GeoJsonSource, with pagination support: limit is the number of leaves
     * to return (set to Infinity for all points), and offset is the amount of points to skip (for pagination).
     *
     * Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
     *
     * @param sourceIdentifier GeoJsonSource identifier.
     * @param cluster Cluster from which to retrieve leaves from
     * @param limit The number of points to return from the query (must use type [Long], set to maximum for all points). Defaults to 10.
     * @param offset The amount of points to skip (for pagination, must use type [Long]). Defaults to 0.
     *         The result is a feature collection or a string describing an error if the operation was not successful.
     */
    void getGeoJsonClusterLeaves(@NonNull String sourceIdentifier, @NonNull Map<String, Object> cluster, @Nullable Long limit, @Nullable Long offset, @NonNull Result<FeatureExtensionValue> result);
    /**
     * Returns the children (original points or clusters) of a cluster (on the next zoom level)
     * given its id (cluster_id value from feature properties) from a GeoJsonSource.
     *
     * Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
     *
     * @param sourceIdentifier GeoJsonSource identifier.
     * @param cluster cluster from which to retrieve children from
     *         The result is a feature collection or a string describing an error if the operation was not successful.
     */
    void getGeoJsonClusterChildren(@NonNull String sourceIdentifier, @NonNull Map<String, Object> cluster, @NonNull Result<FeatureExtensionValue> result);
    /**
     * Returns the zoom on which the cluster expands into several children (useful for "click to zoom" feature)
     * given the cluster's cluster_id (cluster_id value from feature properties) from a GeoJsonSource.
     *
     * Requires configuring the source as a cluster by calling [GeoJsonSource.Builder#cluster(boolean)].
     *
     * @param sourceIdentifier GeoJsonSource identifier.
     * @param cluster cluster from which to retrieve the expansion zoom from
     *         The result is a feature extension value containing a value or a string describing an error if the operation was not successful.
     */
    void getGeoJsonClusterExpansionZoom(@NonNull String sourceIdentifier, @NonNull Map<String, Object> cluster, @NonNull Result<FeatureExtensionValue> result);
    /**
     * Updates the state object of a feature within a style source.
     *
     * Update entries in the `state` object of a given feature within a style source. Only properties of the
     * `state` object will be updated. A property in the feature `state` object that is not listed in `state` will
     * retain its previous value.
     *
     * Note that updates to feature `state` are asynchronous, so changes made by this method migth not be
     * immediately visible using `getStateFeature`.
     *
     * @param sourceId The style source identifier.
     * @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
     * @param featureId The feature identifier of the feature whose state should be updated.
     * @param state The `state` object with properties to update with their respective new values.
     */
    void setFeatureState(@NonNull String sourceId, @Nullable String sourceLayerId, @NonNull String featureId, @NonNull String state);
    /**
     * Gets the state map of a feature within a style source.
     *
     * Note that updates to feature state are asynchronous, so changes made by other methods might not be
     * immediately visible.
     *
     * @param sourceId The style source identifier.
     * @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
     * @param featureId The feature identifier of the feature whose state should be queried.
     */
    void getFeatureState(@NonNull String sourceId, @Nullable String sourceLayerId, @NonNull String featureId, @NonNull Result<String> result);
    /**
     * Removes entries from a feature state object.
     *
     * Remove a specified property or all property from a feature's state object, depending on the value of
     * `stateKey`.
     *
     * Note that updates to feature state are asynchronous, so changes made by this method migth not be
     * immediately visible using `getStateFeature`.
     *
     * @param sourceId The style source identifier.
     * @param sourceLayerId The style source layer identifier (for multi-layer sources such as vector sources).
     * @param featureId The feature identifier of the feature whose state should be removed.
     * @param stateKey The key of the property to remove. If `null`, all feature's state object properties are removed.
     */
    void removeFeatureState(@NonNull String sourceId, @Nullable String sourceLayerId, @NonNull String featureId, @Nullable String stateKey);
    /** Reduces memory use. Useful to call when the application gets paused or sent to background. */
    void reduceMemoryUse();
    /**
     * Gets the resource options for the map.
     *
     * All optional fields of the retuned object are initialized with the actual values.
     *
     * Note that result of this method is different from the `resource options` that were provided to the map's constructor.
     *
     * @return The `resource options` for the map.
     */
    @NonNull 
    ResourceOptions getResourceOptions();
    /**
     * Gets elevation for the given coordinate.
     * Note: Elevation is only available for the visible region on the screen.
     *
     * @param coordinate The `coordinate` defined as longitude-latitude pair.
     * @return The elevation (in meters) multiplied by current terrain exaggeration, or empty if elevation for the coordinate is not available.
     */
    @Nullable 
    Double getElevation(@NonNull Map<String, Object> coordinate);

    /** The codec used by _MapInterface. */
    static @NonNull MessageCodec<Object> getCodec() {
      return _MapInterfaceCodec.INSTANCE;
    }
    /**Sets up an instance of `_MapInterface` to handle messages through the `binaryMessenger`. */
    static void setup(@NonNull BinaryMessenger binaryMessenger, @Nullable _MapInterface api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.loadStyleURI", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String styleURIArg = (String) args.get(0);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.loadStyleURI(styleURIArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.loadStyleJson", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String styleJsonArg = (String) args.get(0);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        // FIXME(all): Without connection, this line crash the app.
                        // reply.reply(wrappedError);
                      }
                    };

                api.loadStyleJson(styleJsonArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.clearData", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.clearData(resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setMemoryBudget", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                MapMemoryBudgetInMegabytes mapMemoryBudgetInMegabytesArg = (MapMemoryBudgetInMegabytes) args.get(0);
                MapMemoryBudgetInTiles mapMemoryBudgetInTilesArg = (MapMemoryBudgetInTiles) args.get(1);
                try {
                  api.setMemoryBudget(mapMemoryBudgetInMegabytesArg, mapMemoryBudgetInTilesArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getSize", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  Size output = api.getSize();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.triggerRepaint", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  api.triggerRepaint();
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setGestureInProgress", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Boolean inProgressArg = (Boolean) args.get(0);
                try {
                  api.setGestureInProgress(inProgressArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.isGestureInProgress", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  Boolean output = api.isGestureInProgress();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setUserAnimationInProgress", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Boolean inProgressArg = (Boolean) args.get(0);
                try {
                  api.setUserAnimationInProgress(inProgressArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.isUserAnimationInProgress", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  Boolean output = api.isUserAnimationInProgress();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setPrefetchZoomDelta", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Number deltaArg = (Number) args.get(0);
                try {
                  api.setPrefetchZoomDelta((deltaArg == null) ? null : deltaArg.longValue());
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getPrefetchZoomDelta", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  Long output = api.getPrefetchZoomDelta();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setNorthOrientation", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                NorthOrientation orientationArg = NorthOrientation.values()[(int) args.get(0)];
                try {
                  api.setNorthOrientation(orientationArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setConstrainMode", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                ConstrainMode modeArg = ConstrainMode.values()[(int) args.get(0)];
                try {
                  api.setConstrainMode(modeArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setViewportMode", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                ViewportMode modeArg = ViewportMode.values()[(int) args.get(0)];
                try {
                  api.setViewportMode(modeArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getMapOptions", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  MapOptions output = api.getMapOptions();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getDebug", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  List<MapDebugOptions> output = api.getDebug();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setDebug", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                List<MapDebugOptions> debugOptionsArg = (List<MapDebugOptions>) args.get(0);
                Boolean valueArg = (Boolean) args.get(1);
                try {
                  api.setDebug(debugOptionsArg, valueArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.queryRenderedFeatures", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                RenderedQueryGeometry geometryArg = (RenderedQueryGeometry) args.get(0);
                RenderedQueryOptions optionsArg = (RenderedQueryOptions) args.get(1);
                Result<List<QueriedFeature>> resultCallback =
                    new Result<List<QueriedFeature>>() {
                      public void success(List<QueriedFeature> result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.queryRenderedFeatures(geometryArg, optionsArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.querySourceFeatures", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                SourceQueryOptions optionsArg = (SourceQueryOptions) args.get(1);
                Result<List<QueriedFeature>> resultCallback =
                    new Result<List<QueriedFeature>>() {
                      public void success(List<QueriedFeature> result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.querySourceFeatures(sourceIdArg, optionsArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getGeoJsonClusterLeaves", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdentifierArg = (String) args.get(0);
                Map<String, Object> clusterArg = (Map<String, Object>) args.get(1);
                Number limitArg = (Number) args.get(2);
                Number offsetArg = (Number) args.get(3);
                Result<FeatureExtensionValue> resultCallback =
                    new Result<FeatureExtensionValue>() {
                      public void success(FeatureExtensionValue result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getGeoJsonClusterLeaves(sourceIdentifierArg, clusterArg, (limitArg == null) ? null : limitArg.longValue(), (offsetArg == null) ? null : offsetArg.longValue(), resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getGeoJsonClusterChildren", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdentifierArg = (String) args.get(0);
                Map<String, Object> clusterArg = (Map<String, Object>) args.get(1);
                Result<FeatureExtensionValue> resultCallback =
                    new Result<FeatureExtensionValue>() {
                      public void success(FeatureExtensionValue result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getGeoJsonClusterChildren(sourceIdentifierArg, clusterArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getGeoJsonClusterExpansionZoom", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdentifierArg = (String) args.get(0);
                Map<String, Object> clusterArg = (Map<String, Object>) args.get(1);
                Result<FeatureExtensionValue> resultCallback =
                    new Result<FeatureExtensionValue>() {
                      public void success(FeatureExtensionValue result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getGeoJsonClusterExpansionZoom(sourceIdentifierArg, clusterArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.setFeatureState", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                String sourceLayerIdArg = (String) args.get(1);
                String featureIdArg = (String) args.get(2);
                String stateArg = (String) args.get(3);
                try {
                  api.setFeatureState(sourceIdArg, sourceLayerIdArg, featureIdArg, stateArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getFeatureState", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                String sourceLayerIdArg = (String) args.get(1);
                String featureIdArg = (String) args.get(2);
                Result<String> resultCallback =
                    new Result<String>() {
                      public void success(String result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getFeatureState(sourceIdArg, sourceLayerIdArg, featureIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.removeFeatureState", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                String sourceLayerIdArg = (String) args.get(1);
                String featureIdArg = (String) args.get(2);
                String stateKeyArg = (String) args.get(3);
                try {
                  api.removeFeatureState(sourceIdArg, sourceLayerIdArg, featureIdArg, stateKeyArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.reduceMemoryUse", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  api.reduceMemoryUse();
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getResourceOptions", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  ResourceOptions output = api.getResourceOptions();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter._MapInterface.getElevation", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Map<String, Object> coordinateArg = (Map<String, Object>) args.get(0);
                try {
                  Double output = api.getElevation(coordinateArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }

  private static class OfflineRegionCodec extends StandardMessageCodec {
    public static final OfflineRegionCodec INSTANCE = new OfflineRegionCodec();

    private OfflineRegionCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return CoordinateBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 129:
          return OfflineRegionGeometryDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 130:
          return OfflineRegionTilePyramidDefinition.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof CoordinateBounds) {
        stream.write(128);
        writeValue(stream, ((CoordinateBounds) value).toList());
      } else if (value instanceof OfflineRegionGeometryDefinition) {
        stream.write(129);
        writeValue(stream, ((OfflineRegionGeometryDefinition) value).toList());
      } else if (value instanceof OfflineRegionTilePyramidDefinition) {
        stream.write(130);
        writeValue(stream, ((OfflineRegionTilePyramidDefinition) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /**
   * An offline region represents an identifiable geographic region with optional metadata.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface OfflineRegion {
    /** The regions identifier */
    @NonNull 
    Long getIdentifier();
    /**
     * The tile pyramid defining the region. Tile pyramid and geometry definitions are
     * mutually exclusive.
     *
     * @return A definition describing the tile pyramid including attributes, otherwise empty.
     */
    @Nullable 
    OfflineRegionTilePyramidDefinition getTilePyramidDefinition();
    /**
     * The geometry defining the region. Geometry and tile pyramid definitions are
     * mutually exclusive.
     *
     * @return A definition describing the geometry including attributes, otherwise empty.
     */
    @Nullable 
    OfflineRegionGeometryDefinition getGeometryDefinition();
    /**
     * Arbitrary binary region metadata.
     *
     * @return The metadata associated with the region.
     */
    @NonNull 
    byte[] getMetadata();
    /**
     * Sets arbitrary binary region metadata for the region.
     *
     * Note that this setter is asynchronous and the given metadata is applied only
     * after the resulting callback is invoked with no error.
     *
     * @param metadata The metadata associated with the region.
     * @param callback Called once the request is complete or an error occurred.
     */
    void setMetadata(@NonNull byte[] metadata, @NonNull Result<Void> result);
    /**
     * Sets the download state of an offline region
     * A region is either inactive (not downloading, but previously-downloaded
     * resources are available for use), or active (resources are being downloaded
     * or will be downloaded, if necessary, when network access is available).
     *
     * If the region is already in the given state, this call is ignored.
     *
     * @param state The new state to set.
     */
    void setOfflineRegionDownloadState(@NonNull OfflineRegionDownloadState state);
    /**
     * Invalidate all the tiles for the region forcing to revalidate
     * the tiles with the server before using. This is more efficient than deleting the
     * offline region and downloading it again because if the data on the cache matches
     * the server, no new data gets transmitted.
     *
     * @param callback Called once the request is complete or an error occurred.
     */
    void invalidate(@NonNull Result<Void> result);
    /**
     * Remove an offline region from the database and perform any resources
     * evictions necessary as a result.
     *
     * @param callback Called once the request is complete or an error occurred.
     */
    void purge(@NonNull Result<Void> result);

    /** The codec used by OfflineRegion. */
    static @NonNull MessageCodec<Object> getCodec() {
      return OfflineRegionCodec.INSTANCE;
    }
    /**Sets up an instance of `OfflineRegion` to handle messages through the `binaryMessenger`. */
    static void setup(@NonNull BinaryMessenger binaryMessenger, @Nullable OfflineRegion api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.getIdentifier", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  Long output = api.getIdentifier();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.getTilePyramidDefinition", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  OfflineRegionTilePyramidDefinition output = api.getTilePyramidDefinition();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.getGeometryDefinition", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  OfflineRegionGeometryDefinition output = api.getGeometryDefinition();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.getMetadata", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  byte[] output = api.getMetadata();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.setMetadata", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                byte[] metadataArg = (byte[]) args.get(0);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setMetadata(metadataArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.setOfflineRegionDownloadState", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                OfflineRegionDownloadState stateArg = OfflineRegionDownloadState.values()[(int) args.get(0)];
                try {
                  api.setOfflineRegionDownloadState(stateArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.invalidate", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.invalidate(resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegion.purge", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.purge(resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }
  /**
   * The `offline region manager` that manages offline packs. All of the class’s instance methods are asynchronous
   * reflecting the fact that offline resources are stored in a database. The offline manager maintains a canonical
   * collection of offline packs.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface OfflineRegionManager {
    /**
     * Sets the maximum number of Mapbox-hosted tiles that may be downloaded and stored on the current device.
     *
     * By default, the limit is set to 6,000.
     * Once this limit is reached, `OfflineRegionObserver.mapboxTileCountLimitExceeded()`
     * fires every additional attempt to download additional tiles until already downloaded tiles are removed
     * by calling `OfflineRegion.purge()` API.
     *
     * @param limit the maximum number of tiles allowed to be downloaded
     */
    void setOfflineMapboxTileCountLimit(@NonNull Long limit);

    /** The codec used by OfflineRegionManager. */
    static @NonNull MessageCodec<Object> getCodec() {
      return new StandardMessageCodec();
    }
    /**Sets up an instance of `OfflineRegionManager` to handle messages through the `binaryMessenger`. */
    static void setup(@NonNull BinaryMessenger binaryMessenger, @Nullable OfflineRegionManager api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineRegionManager.setOfflineMapboxTileCountLimit", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Number limitArg = (Number) args.get(0);
                try {
                  api.setOfflineMapboxTileCountLimit((limitArg == null) ? null : limitArg.longValue());
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }

  private static class ProjectionCodec extends StandardMessageCodec {
    public static final ProjectionCodec INSTANCE = new ProjectionCodec();

    private ProjectionCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return CameraBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 129:
          return CameraBoundsOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 130:
          return CameraOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 131:
          return CameraState.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 132:
          return CanonicalTileID.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 133:
          return CoordinateBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 134:
          return CoordinateBoundsZoom.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 135:
          return FeatureExtensionValue.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 136:
          return GlyphsRasterizationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 137:
          return ImageContent.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 138:
          return ImageStretches.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 139:
          return LayerPosition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 140:
          return MapAnimationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 141:
          return MapDebugOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 142:
          return MapMemoryBudgetInMegabytes.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 143:
          return MapMemoryBudgetInTiles.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 144:
          return MapOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 145:
          return MbxEdgeInsets.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 146:
          return MbxImage.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 147:
          return MercatorCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 148:
          return OfflineRegionGeometryDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 149:
          return OfflineRegionTilePyramidDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 150:
          return ProjectedMeters.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 151:
          return QueriedFeature.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 152:
          return RenderedQueryGeometry.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 153:
          return RenderedQueryOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 154:
          return ResourceOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 155:
          return ScreenBox.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 156:
          return ScreenCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 157:
          return Size.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 158:
          return SourceQueryOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 159:
          return StyleObjectInfo.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 160:
          return StylePropertyValue.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 161:
          return TransitionOptions.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof CameraBounds) {
        stream.write(128);
        writeValue(stream, ((CameraBounds) value).toList());
      } else if (value instanceof CameraBoundsOptions) {
        stream.write(129);
        writeValue(stream, ((CameraBoundsOptions) value).toList());
      } else if (value instanceof CameraOptions) {
        stream.write(130);
        writeValue(stream, ((CameraOptions) value).toList());
      } else if (value instanceof CameraState) {
        stream.write(131);
        writeValue(stream, ((CameraState) value).toList());
      } else if (value instanceof CanonicalTileID) {
        stream.write(132);
        writeValue(stream, ((CanonicalTileID) value).toList());
      } else if (value instanceof CoordinateBounds) {
        stream.write(133);
        writeValue(stream, ((CoordinateBounds) value).toList());
      } else if (value instanceof CoordinateBoundsZoom) {
        stream.write(134);
        writeValue(stream, ((CoordinateBoundsZoom) value).toList());
      } else if (value instanceof FeatureExtensionValue) {
        stream.write(135);
        writeValue(stream, ((FeatureExtensionValue) value).toList());
      } else if (value instanceof GlyphsRasterizationOptions) {
        stream.write(136);
        writeValue(stream, ((GlyphsRasterizationOptions) value).toList());
      } else if (value instanceof ImageContent) {
        stream.write(137);
        writeValue(stream, ((ImageContent) value).toList());
      } else if (value instanceof ImageStretches) {
        stream.write(138);
        writeValue(stream, ((ImageStretches) value).toList());
      } else if (value instanceof LayerPosition) {
        stream.write(139);
        writeValue(stream, ((LayerPosition) value).toList());
      } else if (value instanceof MapAnimationOptions) {
        stream.write(140);
        writeValue(stream, ((MapAnimationOptions) value).toList());
      } else if (value instanceof MapDebugOptions) {
        stream.write(141);
        writeValue(stream, ((MapDebugOptions) value).toList());
      } else if (value instanceof MapMemoryBudgetInMegabytes) {
        stream.write(142);
        writeValue(stream, ((MapMemoryBudgetInMegabytes) value).toList());
      } else if (value instanceof MapMemoryBudgetInTiles) {
        stream.write(143);
        writeValue(stream, ((MapMemoryBudgetInTiles) value).toList());
      } else if (value instanceof MapOptions) {
        stream.write(144);
        writeValue(stream, ((MapOptions) value).toList());
      } else if (value instanceof MbxEdgeInsets) {
        stream.write(145);
        writeValue(stream, ((MbxEdgeInsets) value).toList());
      } else if (value instanceof MbxImage) {
        stream.write(146);
        writeValue(stream, ((MbxImage) value).toList());
      } else if (value instanceof MercatorCoordinate) {
        stream.write(147);
        writeValue(stream, ((MercatorCoordinate) value).toList());
      } else if (value instanceof OfflineRegionGeometryDefinition) {
        stream.write(148);
        writeValue(stream, ((OfflineRegionGeometryDefinition) value).toList());
      } else if (value instanceof OfflineRegionTilePyramidDefinition) {
        stream.write(149);
        writeValue(stream, ((OfflineRegionTilePyramidDefinition) value).toList());
      } else if (value instanceof ProjectedMeters) {
        stream.write(150);
        writeValue(stream, ((ProjectedMeters) value).toList());
      } else if (value instanceof QueriedFeature) {
        stream.write(151);
        writeValue(stream, ((QueriedFeature) value).toList());
      } else if (value instanceof RenderedQueryGeometry) {
        stream.write(152);
        writeValue(stream, ((RenderedQueryGeometry) value).toList());
      } else if (value instanceof RenderedQueryOptions) {
        stream.write(153);
        writeValue(stream, ((RenderedQueryOptions) value).toList());
      } else if (value instanceof ResourceOptions) {
        stream.write(154);
        writeValue(stream, ((ResourceOptions) value).toList());
      } else if (value instanceof ScreenBox) {
        stream.write(155);
        writeValue(stream, ((ScreenBox) value).toList());
      } else if (value instanceof ScreenCoordinate) {
        stream.write(156);
        writeValue(stream, ((ScreenCoordinate) value).toList());
      } else if (value instanceof Size) {
        stream.write(157);
        writeValue(stream, ((Size) value).toList());
      } else if (value instanceof SourceQueryOptions) {
        stream.write(158);
        writeValue(stream, ((SourceQueryOptions) value).toList());
      } else if (value instanceof StyleObjectInfo) {
        stream.write(159);
        writeValue(stream, ((StyleObjectInfo) value).toList());
      } else if (value instanceof StylePropertyValue) {
        stream.write(160);
        writeValue(stream, ((StylePropertyValue) value).toList());
      } else if (value instanceof TransitionOptions) {
        stream.write(161);
        writeValue(stream, ((TransitionOptions) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /**
   * Collection of [Spherical Mercator](http://docs.openlayers.org/library/spherical_mercator.html) projection methods.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface Projection {
    /**
     * Calculate distance spanned by one pixel at the specified latitude
     * and zoom level.
     *
     * @param latitude The latitude for which to return the value.
     * @param zoom The zoom level.
     *
     * @return Returns the distance measured in meters.
     */
    @NonNull 
    Double getMetersPerPixelAtLatitude(@NonNull Double latitude, @NonNull Double zoom);
    /**
     * Calculate Spherical Mercator ProjectedMeters coordinates.
     *
     * @param coordinate A longitude-latitude pair for which to calculate
     * `projected meters` coordinates.
     *
     * @return Returns Spherical Mercator ProjectedMeters coordinates.
     */
    @NonNull 
    ProjectedMeters projectedMetersForCoordinate(@NonNull Map<String, Object> coordinate);
    /**
     * Calculate a longitude-latitude pair for a Spherical Mercator projected
     * meters.
     *
     * @param projectedMeters Spherical Mercator ProjectedMeters coordinates for
     * which to calculate a longitude-latitude pair.
     *
     * @return Returns a longitude-latitude pair.
     */
    @NonNull 
    Map<String, Object> coordinateForProjectedMeters(@NonNull ProjectedMeters projectedMeters);
    /**
     * Calculate a point on the map in Mercator Projection for a given
     * coordinate at the specified zoom scale.
     *
     * @param coordinate The longitude-latitude pair for which to return the value.
     * @param zoomScale The current zoom factor (2 ^ Zoom level) applied on the map, is used to
     * calculate the world size as tileSize * zoomScale (i.e., 512 * 2 ^ Zoom level)
     * where tileSize is the width of a tile in pixels.
     *
     * @return Returns a point on the map in Mercator projection.
     */
    @NonNull 
    MercatorCoordinate project(@NonNull Map<String, Object> coordinate, @NonNull Double zoomScale);
    /**
     * Calculate a coordinate for a given point on the map in Mercator Projection.
     *
     * @param coordinate Point on the map in Mercator projection.
     * @param zoomScale The current zoom factor applied on the map, is used to
     * calculate the world size as tileSize * zoomScale (i.e., 512 * 2 ^ Zoom level)
     * where tileSize is the width of a tile in pixels.
     *
     * @return Returns a coordinate.
     */
    @NonNull 
    Map<String, Object> unproject(@NonNull MercatorCoordinate coordinate, @NonNull Double zoomScale);

    /** The codec used by Projection. */
    static @NonNull MessageCodec<Object> getCodec() {
      return ProjectionCodec.INSTANCE;
    }
    /**Sets up an instance of `Projection` to handle messages through the `binaryMessenger`. */
    static void setup(@NonNull BinaryMessenger binaryMessenger, @Nullable Projection api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Projection.getMetersPerPixelAtLatitude", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Double latitudeArg = (Double) args.get(0);
                Double zoomArg = (Double) args.get(1);
                try {
                  Double output = api.getMetersPerPixelAtLatitude(latitudeArg, zoomArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Projection.projectedMetersForCoordinate", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Map<String, Object> coordinateArg = (Map<String, Object>) args.get(0);
                try {
                  ProjectedMeters output = api.projectedMetersForCoordinate(coordinateArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Projection.coordinateForProjectedMeters", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                ProjectedMeters projectedMetersArg = (ProjectedMeters) args.get(0);
                try {
                  Map<String, Object> output = api.coordinateForProjectedMeters(projectedMetersArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Projection.project", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Map<String, Object> coordinateArg = (Map<String, Object>) args.get(0);
                Double zoomScaleArg = (Double) args.get(1);
                try {
                  MercatorCoordinate output = api.project(coordinateArg, zoomScaleArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Projection.unproject", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                MercatorCoordinate coordinateArg = (MercatorCoordinate) args.get(0);
                Double zoomScaleArg = (Double) args.get(1);
                try {
                  Map<String, Object> output = api.unproject(coordinateArg, zoomScaleArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }
  /**
   * Settings class provides non-persistent, in-process key-value storage.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface Settings {
    /**
     * Sets setting value for a specified key.
     *
     * @param key A name of the key.
     * @param value The `value` for the key.
     */
    void set(@NonNull String key, @NonNull String value);
    /**
     * Return value for a key.
     *
     * @param key A name of the key.
     *
     * @return `value` if a key exists in settings otherwise a `null value` will be returned.
     */
    @NonNull 
    String get(@NonNull String key);

    /** The codec used by Settings. */
    static @NonNull MessageCodec<Object> getCodec() {
      return new StandardMessageCodec();
    }
    /**Sets up an instance of `Settings` to handle messages through the `binaryMessenger`. */
    static void setup(@NonNull BinaryMessenger binaryMessenger, @Nullable Settings api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Settings.set", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String keyArg = (String) args.get(0);
                String valueArg = (String) args.get(1);
                try {
                  api.set(keyArg, valueArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Settings.get", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String keyArg = (String) args.get(0);
                try {
                  String output = api.get(keyArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }

  private static class MapSnapshotCodec extends StandardMessageCodec {
    public static final MapSnapshotCodec INSTANCE = new MapSnapshotCodec();

    private MapSnapshotCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return CameraBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 129:
          return CameraBoundsOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 130:
          return CameraOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 131:
          return CameraState.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 132:
          return CanonicalTileID.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 133:
          return CoordinateBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 134:
          return CoordinateBoundsZoom.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 135:
          return FeatureExtensionValue.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 136:
          return GlyphsRasterizationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 137:
          return ImageContent.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 138:
          return ImageStretches.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 139:
          return LayerPosition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 140:
          return MapAnimationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 141:
          return MapDebugOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 142:
          return MapMemoryBudgetInMegabytes.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 143:
          return MapMemoryBudgetInTiles.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 144:
          return MapOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 145:
          return MbxEdgeInsets.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 146:
          return MbxImage.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 147:
          return MercatorCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 148:
          return OfflineRegionGeometryDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 149:
          return OfflineRegionTilePyramidDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 150:
          return ProjectedMeters.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 151:
          return QueriedFeature.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 152:
          return RenderedQueryGeometry.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 153:
          return RenderedQueryOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 154:
          return ResourceOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 155:
          return ScreenBox.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 156:
          return ScreenCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 157:
          return Size.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 158:
          return SourceQueryOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 159:
          return StyleObjectInfo.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 160:
          return StylePropertyValue.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 161:
          return TransitionOptions.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof CameraBounds) {
        stream.write(128);
        writeValue(stream, ((CameraBounds) value).toList());
      } else if (value instanceof CameraBoundsOptions) {
        stream.write(129);
        writeValue(stream, ((CameraBoundsOptions) value).toList());
      } else if (value instanceof CameraOptions) {
        stream.write(130);
        writeValue(stream, ((CameraOptions) value).toList());
      } else if (value instanceof CameraState) {
        stream.write(131);
        writeValue(stream, ((CameraState) value).toList());
      } else if (value instanceof CanonicalTileID) {
        stream.write(132);
        writeValue(stream, ((CanonicalTileID) value).toList());
      } else if (value instanceof CoordinateBounds) {
        stream.write(133);
        writeValue(stream, ((CoordinateBounds) value).toList());
      } else if (value instanceof CoordinateBoundsZoom) {
        stream.write(134);
        writeValue(stream, ((CoordinateBoundsZoom) value).toList());
      } else if (value instanceof FeatureExtensionValue) {
        stream.write(135);
        writeValue(stream, ((FeatureExtensionValue) value).toList());
      } else if (value instanceof GlyphsRasterizationOptions) {
        stream.write(136);
        writeValue(stream, ((GlyphsRasterizationOptions) value).toList());
      } else if (value instanceof ImageContent) {
        stream.write(137);
        writeValue(stream, ((ImageContent) value).toList());
      } else if (value instanceof ImageStretches) {
        stream.write(138);
        writeValue(stream, ((ImageStretches) value).toList());
      } else if (value instanceof LayerPosition) {
        stream.write(139);
        writeValue(stream, ((LayerPosition) value).toList());
      } else if (value instanceof MapAnimationOptions) {
        stream.write(140);
        writeValue(stream, ((MapAnimationOptions) value).toList());
      } else if (value instanceof MapDebugOptions) {
        stream.write(141);
        writeValue(stream, ((MapDebugOptions) value).toList());
      } else if (value instanceof MapMemoryBudgetInMegabytes) {
        stream.write(142);
        writeValue(stream, ((MapMemoryBudgetInMegabytes) value).toList());
      } else if (value instanceof MapMemoryBudgetInTiles) {
        stream.write(143);
        writeValue(stream, ((MapMemoryBudgetInTiles) value).toList());
      } else if (value instanceof MapOptions) {
        stream.write(144);
        writeValue(stream, ((MapOptions) value).toList());
      } else if (value instanceof MbxEdgeInsets) {
        stream.write(145);
        writeValue(stream, ((MbxEdgeInsets) value).toList());
      } else if (value instanceof MbxImage) {
        stream.write(146);
        writeValue(stream, ((MbxImage) value).toList());
      } else if (value instanceof MercatorCoordinate) {
        stream.write(147);
        writeValue(stream, ((MercatorCoordinate) value).toList());
      } else if (value instanceof OfflineRegionGeometryDefinition) {
        stream.write(148);
        writeValue(stream, ((OfflineRegionGeometryDefinition) value).toList());
      } else if (value instanceof OfflineRegionTilePyramidDefinition) {
        stream.write(149);
        writeValue(stream, ((OfflineRegionTilePyramidDefinition) value).toList());
      } else if (value instanceof ProjectedMeters) {
        stream.write(150);
        writeValue(stream, ((ProjectedMeters) value).toList());
      } else if (value instanceof QueriedFeature) {
        stream.write(151);
        writeValue(stream, ((QueriedFeature) value).toList());
      } else if (value instanceof RenderedQueryGeometry) {
        stream.write(152);
        writeValue(stream, ((RenderedQueryGeometry) value).toList());
      } else if (value instanceof RenderedQueryOptions) {
        stream.write(153);
        writeValue(stream, ((RenderedQueryOptions) value).toList());
      } else if (value instanceof ResourceOptions) {
        stream.write(154);
        writeValue(stream, ((ResourceOptions) value).toList());
      } else if (value instanceof ScreenBox) {
        stream.write(155);
        writeValue(stream, ((ScreenBox) value).toList());
      } else if (value instanceof ScreenCoordinate) {
        stream.write(156);
        writeValue(stream, ((ScreenCoordinate) value).toList());
      } else if (value instanceof Size) {
        stream.write(157);
        writeValue(stream, ((Size) value).toList());
      } else if (value instanceof SourceQueryOptions) {
        stream.write(158);
        writeValue(stream, ((SourceQueryOptions) value).toList());
      } else if (value instanceof StyleObjectInfo) {
        stream.write(159);
        writeValue(stream, ((StyleObjectInfo) value).toList());
      } else if (value instanceof StylePropertyValue) {
        stream.write(160);
        writeValue(stream, ((StylePropertyValue) value).toList());
      } else if (value instanceof TransitionOptions) {
        stream.write(161);
        writeValue(stream, ((TransitionOptions) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /**
   * An image snapshot of a map rendered by `map snapshotter`.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface MapSnapshot {
    /**
     * Calculate screen coordinate on the snapshot from geographical `coordinate`.
     *
     * @param coordinate A geographical `coordinate`.
     * @return A `screen coordinate` measured in `platform pixels` on the snapshot for geographical `coordinate`.
     */
    @NonNull 
    ScreenCoordinate screenCoordinate(@NonNull Map<String, Object> coordinate);
    /**
     * Calculate geographical coordinates from a point on the snapshot.
     *
     * @param screenCoordinate A `screen coordinate` on the snapshot in `platform pixels`.
     * @return A geographical `coordinate` for a `screen coordinate` on the snapshot.
     */
    @NonNull 
    Map<String, Object> coordinate(@NonNull ScreenCoordinate screenCoordinate);
    /**
     * Get list of attributions for the sources in this snapshot.
     *
     * @return A list of attributions for the sources in this snapshot.
     */
    @NonNull 
    List<String> attributions();
    /**
     * Get the rendered snapshot `image`.
     *
     * @return A rendered snapshot `image`.
     */
    @NonNull 
    MbxImage image();

    /** The codec used by MapSnapshot. */
    static @NonNull MessageCodec<Object> getCodec() {
      return MapSnapshotCodec.INSTANCE;
    }
    /**Sets up an instance of `MapSnapshot` to handle messages through the `binaryMessenger`. */
    static void setup(@NonNull BinaryMessenger binaryMessenger, @Nullable MapSnapshot api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshot.screenCoordinate", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Map<String, Object> coordinateArg = (Map<String, Object>) args.get(0);
                try {
                  ScreenCoordinate output = api.screenCoordinate(coordinateArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshot.coordinate", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                ScreenCoordinate screenCoordinateArg = (ScreenCoordinate) args.get(0);
                try {
                  Map<String, Object> output = api.coordinate(screenCoordinateArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshot.attributions", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  List<String> output = api.attributions();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshot.image", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  MbxImage output = api.image();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }

  private static class MapSnapshotterCodec extends StandardMessageCodec {
    public static final MapSnapshotterCodec INSTANCE = new MapSnapshotterCodec();

    private MapSnapshotterCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return CameraBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 129:
          return CameraBoundsOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 130:
          return CameraOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 131:
          return CameraState.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 132:
          return CanonicalTileID.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 133:
          return CoordinateBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 134:
          return CoordinateBoundsZoom.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 135:
          return FeatureExtensionValue.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 136:
          return GlyphsRasterizationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 137:
          return ImageContent.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 138:
          return ImageStretches.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 139:
          return LayerPosition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 140:
          return MapAnimationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 141:
          return MapDebugOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 142:
          return MapMemoryBudgetInMegabytes.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 143:
          return MapMemoryBudgetInTiles.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 144:
          return MapOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 145:
          return MbxEdgeInsets.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 146:
          return MbxImage.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 147:
          return MercatorCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 148:
          return OfflineRegionGeometryDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 149:
          return OfflineRegionTilePyramidDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 150:
          return ProjectedMeters.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 151:
          return QueriedFeature.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 152:
          return RenderedQueryGeometry.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 153:
          return RenderedQueryOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 154:
          return ResourceOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 155:
          return ScreenBox.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 156:
          return ScreenCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 157:
          return Size.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 158:
          return SourceQueryOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 159:
          return StyleObjectInfo.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 160:
          return StylePropertyValue.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 161:
          return TransitionOptions.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof CameraBounds) {
        stream.write(128);
        writeValue(stream, ((CameraBounds) value).toList());
      } else if (value instanceof CameraBoundsOptions) {
        stream.write(129);
        writeValue(stream, ((CameraBoundsOptions) value).toList());
      } else if (value instanceof CameraOptions) {
        stream.write(130);
        writeValue(stream, ((CameraOptions) value).toList());
      } else if (value instanceof CameraState) {
        stream.write(131);
        writeValue(stream, ((CameraState) value).toList());
      } else if (value instanceof CanonicalTileID) {
        stream.write(132);
        writeValue(stream, ((CanonicalTileID) value).toList());
      } else if (value instanceof CoordinateBounds) {
        stream.write(133);
        writeValue(stream, ((CoordinateBounds) value).toList());
      } else if (value instanceof CoordinateBoundsZoom) {
        stream.write(134);
        writeValue(stream, ((CoordinateBoundsZoom) value).toList());
      } else if (value instanceof FeatureExtensionValue) {
        stream.write(135);
        writeValue(stream, ((FeatureExtensionValue) value).toList());
      } else if (value instanceof GlyphsRasterizationOptions) {
        stream.write(136);
        writeValue(stream, ((GlyphsRasterizationOptions) value).toList());
      } else if (value instanceof ImageContent) {
        stream.write(137);
        writeValue(stream, ((ImageContent) value).toList());
      } else if (value instanceof ImageStretches) {
        stream.write(138);
        writeValue(stream, ((ImageStretches) value).toList());
      } else if (value instanceof LayerPosition) {
        stream.write(139);
        writeValue(stream, ((LayerPosition) value).toList());
      } else if (value instanceof MapAnimationOptions) {
        stream.write(140);
        writeValue(stream, ((MapAnimationOptions) value).toList());
      } else if (value instanceof MapDebugOptions) {
        stream.write(141);
        writeValue(stream, ((MapDebugOptions) value).toList());
      } else if (value instanceof MapMemoryBudgetInMegabytes) {
        stream.write(142);
        writeValue(stream, ((MapMemoryBudgetInMegabytes) value).toList());
      } else if (value instanceof MapMemoryBudgetInTiles) {
        stream.write(143);
        writeValue(stream, ((MapMemoryBudgetInTiles) value).toList());
      } else if (value instanceof MapOptions) {
        stream.write(144);
        writeValue(stream, ((MapOptions) value).toList());
      } else if (value instanceof MbxEdgeInsets) {
        stream.write(145);
        writeValue(stream, ((MbxEdgeInsets) value).toList());
      } else if (value instanceof MbxImage) {
        stream.write(146);
        writeValue(stream, ((MbxImage) value).toList());
      } else if (value instanceof MercatorCoordinate) {
        stream.write(147);
        writeValue(stream, ((MercatorCoordinate) value).toList());
      } else if (value instanceof OfflineRegionGeometryDefinition) {
        stream.write(148);
        writeValue(stream, ((OfflineRegionGeometryDefinition) value).toList());
      } else if (value instanceof OfflineRegionTilePyramidDefinition) {
        stream.write(149);
        writeValue(stream, ((OfflineRegionTilePyramidDefinition) value).toList());
      } else if (value instanceof ProjectedMeters) {
        stream.write(150);
        writeValue(stream, ((ProjectedMeters) value).toList());
      } else if (value instanceof QueriedFeature) {
        stream.write(151);
        writeValue(stream, ((QueriedFeature) value).toList());
      } else if (value instanceof RenderedQueryGeometry) {
        stream.write(152);
        writeValue(stream, ((RenderedQueryGeometry) value).toList());
      } else if (value instanceof RenderedQueryOptions) {
        stream.write(153);
        writeValue(stream, ((RenderedQueryOptions) value).toList());
      } else if (value instanceof ResourceOptions) {
        stream.write(154);
        writeValue(stream, ((ResourceOptions) value).toList());
      } else if (value instanceof ScreenBox) {
        stream.write(155);
        writeValue(stream, ((ScreenBox) value).toList());
      } else if (value instanceof ScreenCoordinate) {
        stream.write(156);
        writeValue(stream, ((ScreenCoordinate) value).toList());
      } else if (value instanceof Size) {
        stream.write(157);
        writeValue(stream, ((Size) value).toList());
      } else if (value instanceof SourceQueryOptions) {
        stream.write(158);
        writeValue(stream, ((SourceQueryOptions) value).toList());
      } else if (value instanceof StyleObjectInfo) {
        stream.write(159);
        writeValue(stream, ((StyleObjectInfo) value).toList());
      } else if (value instanceof StylePropertyValue) {
        stream.write(160);
        writeValue(stream, ((StylePropertyValue) value).toList());
      } else if (value instanceof TransitionOptions) {
        stream.write(161);
        writeValue(stream, ((TransitionOptions) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /**
   * MapSnapshotter exposes functionality to capture static map images.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface MapSnapshotter {
    /**
     * Sets the `size` of the snapshot
     *
     * @param size The new `size` of the snapshot in `platform pixels`.
     */
    void setSize(@NonNull Size size);
    /**
     * Gets the size of the snapshot
     *
     * @return Snapshot `size` in `platform pixels`.
     */
    @NonNull 
    Size getSize();
    /**
     * Returns `true` if the snapshotter is in the tile mode.
     *
     * @return `true` if the snapshotter is in the tile mode, `false` otherwise.
     */
    @NonNull 
    Boolean isInTileMode();
    /**
     * Sets the snapshotter to the tile mode.
     *
     * In the tile mode, the snapshotter fetches the still image of a single tile.
     *
     * @param set A `boolean` value representing if the snapshotter is in the tile mode.
     */
    void setTileMode(@NonNull Boolean set);
    /**
     * Cancel the current snapshot operation.
     *
     * Cancel the current snapshot operation, if any. The callback passed to the start method
     * is called with error parameter set.
     */
    void cancel();
    /**
     * Get elevation for the given coordinate.
     * Note: Elevation is only available for the visible region on the screen.
     *
     * @param coordinate defined as longitude-latitude pair.
     *
     * @return Elevation (in meters) multiplied by current terrain exaggeration, or empty if elevation for the coordinate is not available.
     */
    @Nullable 
    Double getElevation(@NonNull Map<String, Object> coordinate);

    /** The codec used by MapSnapshotter. */
    static @NonNull MessageCodec<Object> getCodec() {
      return MapSnapshotterCodec.INSTANCE;
    }
    /**Sets up an instance of `MapSnapshotter` to handle messages through the `binaryMessenger`. */
    static void setup(@NonNull BinaryMessenger binaryMessenger, @Nullable MapSnapshotter api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshotter.setSize", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Size sizeArg = (Size) args.get(0);
                try {
                  api.setSize(sizeArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshotter.getSize", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  Size output = api.getSize();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshotter.isInTileMode", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  Boolean output = api.isInTileMode();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshotter.setTileMode", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Boolean setArg = (Boolean) args.get(0);
                try {
                  api.setTileMode(setArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshotter.cancel", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  api.cancel();
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.MapSnapshotter.getElevation", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Map<String, Object> coordinateArg = (Map<String, Object>) args.get(0);
                try {
                  Double output = api.getElevation(coordinateArg);
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }

  private static class StyleManagerCodec extends StandardMessageCodec {
    public static final StyleManagerCodec INSTANCE = new StyleManagerCodec();

    private StyleManagerCodec() {}

    @Override
    protected Object readValueOfType(byte type, @NonNull ByteBuffer buffer) {
      switch (type) {
        case (byte) 128:
          return CameraBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 129:
          return CameraBoundsOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 130:
          return CameraOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 131:
          return CameraState.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 132:
          return CanonicalTileID.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 133:
          return CoordinateBounds.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 134:
          return CoordinateBoundsZoom.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 135:
          return FeatureExtensionValue.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 136:
          return GlyphsRasterizationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 137:
          return ImageContent.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 138:
          return ImageStretches.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 139:
          return LayerPosition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 140:
          return MapAnimationOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 141:
          return MapDebugOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 142:
          return MapMemoryBudgetInMegabytes.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 143:
          return MapMemoryBudgetInTiles.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 144:
          return MapOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 145:
          return MbxEdgeInsets.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 146:
          return MbxImage.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 147:
          return MercatorCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 148:
          return OfflineRegionGeometryDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 149:
          return OfflineRegionTilePyramidDefinition.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 150:
          return ProjectedMeters.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 151:
          return QueriedFeature.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 152:
          return RenderedQueryGeometry.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 153:
          return RenderedQueryOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 154:
          return ResourceOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 155:
          return ScreenBox.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 156:
          return ScreenCoordinate.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 157:
          return Size.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 158:
          return SourceQueryOptions.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 159:
          return StyleObjectInfo.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 160:
          return StylePropertyValue.fromList((ArrayList<Object>) readValue(buffer));
        case (byte) 161:
          return TransitionOptions.fromList((ArrayList<Object>) readValue(buffer));
        default:
          return super.readValueOfType(type, buffer);
      }
    }

    @Override
    protected void writeValue(@NonNull ByteArrayOutputStream stream, Object value) {
      if (value instanceof CameraBounds) {
        stream.write(128);
        writeValue(stream, ((CameraBounds) value).toList());
      } else if (value instanceof CameraBoundsOptions) {
        stream.write(129);
        writeValue(stream, ((CameraBoundsOptions) value).toList());
      } else if (value instanceof CameraOptions) {
        stream.write(130);
        writeValue(stream, ((CameraOptions) value).toList());
      } else if (value instanceof CameraState) {
        stream.write(131);
        writeValue(stream, ((CameraState) value).toList());
      } else if (value instanceof CanonicalTileID) {
        stream.write(132);
        writeValue(stream, ((CanonicalTileID) value).toList());
      } else if (value instanceof CoordinateBounds) {
        stream.write(133);
        writeValue(stream, ((CoordinateBounds) value).toList());
      } else if (value instanceof CoordinateBoundsZoom) {
        stream.write(134);
        writeValue(stream, ((CoordinateBoundsZoom) value).toList());
      } else if (value instanceof FeatureExtensionValue) {
        stream.write(135);
        writeValue(stream, ((FeatureExtensionValue) value).toList());
      } else if (value instanceof GlyphsRasterizationOptions) {
        stream.write(136);
        writeValue(stream, ((GlyphsRasterizationOptions) value).toList());
      } else if (value instanceof ImageContent) {
        stream.write(137);
        writeValue(stream, ((ImageContent) value).toList());
      } else if (value instanceof ImageStretches) {
        stream.write(138);
        writeValue(stream, ((ImageStretches) value).toList());
      } else if (value instanceof LayerPosition) {
        stream.write(139);
        writeValue(stream, ((LayerPosition) value).toList());
      } else if (value instanceof MapAnimationOptions) {
        stream.write(140);
        writeValue(stream, ((MapAnimationOptions) value).toList());
      } else if (value instanceof MapDebugOptions) {
        stream.write(141);
        writeValue(stream, ((MapDebugOptions) value).toList());
      } else if (value instanceof MapMemoryBudgetInMegabytes) {
        stream.write(142);
        writeValue(stream, ((MapMemoryBudgetInMegabytes) value).toList());
      } else if (value instanceof MapMemoryBudgetInTiles) {
        stream.write(143);
        writeValue(stream, ((MapMemoryBudgetInTiles) value).toList());
      } else if (value instanceof MapOptions) {
        stream.write(144);
        writeValue(stream, ((MapOptions) value).toList());
      } else if (value instanceof MbxEdgeInsets) {
        stream.write(145);
        writeValue(stream, ((MbxEdgeInsets) value).toList());
      } else if (value instanceof MbxImage) {
        stream.write(146);
        writeValue(stream, ((MbxImage) value).toList());
      } else if (value instanceof MercatorCoordinate) {
        stream.write(147);
        writeValue(stream, ((MercatorCoordinate) value).toList());
      } else if (value instanceof OfflineRegionGeometryDefinition) {
        stream.write(148);
        writeValue(stream, ((OfflineRegionGeometryDefinition) value).toList());
      } else if (value instanceof OfflineRegionTilePyramidDefinition) {
        stream.write(149);
        writeValue(stream, ((OfflineRegionTilePyramidDefinition) value).toList());
      } else if (value instanceof ProjectedMeters) {
        stream.write(150);
        writeValue(stream, ((ProjectedMeters) value).toList());
      } else if (value instanceof QueriedFeature) {
        stream.write(151);
        writeValue(stream, ((QueriedFeature) value).toList());
      } else if (value instanceof RenderedQueryGeometry) {
        stream.write(152);
        writeValue(stream, ((RenderedQueryGeometry) value).toList());
      } else if (value instanceof RenderedQueryOptions) {
        stream.write(153);
        writeValue(stream, ((RenderedQueryOptions) value).toList());
      } else if (value instanceof ResourceOptions) {
        stream.write(154);
        writeValue(stream, ((ResourceOptions) value).toList());
      } else if (value instanceof ScreenBox) {
        stream.write(155);
        writeValue(stream, ((ScreenBox) value).toList());
      } else if (value instanceof ScreenCoordinate) {
        stream.write(156);
        writeValue(stream, ((ScreenCoordinate) value).toList());
      } else if (value instanceof Size) {
        stream.write(157);
        writeValue(stream, ((Size) value).toList());
      } else if (value instanceof SourceQueryOptions) {
        stream.write(158);
        writeValue(stream, ((SourceQueryOptions) value).toList());
      } else if (value instanceof StyleObjectInfo) {
        stream.write(159);
        writeValue(stream, ((StyleObjectInfo) value).toList());
      } else if (value instanceof StylePropertyValue) {
        stream.write(160);
        writeValue(stream, ((StylePropertyValue) value).toList());
      } else if (value instanceof TransitionOptions) {
        stream.write(161);
        writeValue(stream, ((TransitionOptions) value).toList());
      } else {
        super.writeValue(stream, value);
      }
    }
  }

  /**
   * Interface for managing style of the `map`.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface StyleManager {
    /**
     * Get the URI of the current style in use.
     *
     * @return A string containing a style URI.
     */
    void getStyleURI(@NonNull Result<String> result);
    /**
     * Load style from provided URI.
     *
     * This is an asynchronous call. To check the result of this operation the user must register an observer observing
     * `MapLoaded` or `MapLoadingError` events. In case of successful style load, `StyleLoaded` event will be also emitted.
     *
     * @param uri URI where the style should be loaded from.
     */
    void setStyleURI(@NonNull String uri, @NonNull Result<Void> result);
    /**
     * Get the JSON serialization string of the current style in use.
     *
     * @return A JSON string containing a serialized style.
     */
    void getStyleJSON(@NonNull Result<String> result);
    /**
     * Load the style from a provided JSON string.
     *
     * @param json A JSON string containing a serialized style.
     */
    void setStyleJSON(@NonNull String json, @NonNull Result<Void> result);
    /**
     * Returns the map style's default camera, if any, or a default camera otherwise.
     * The map style's default camera is defined as follows:
     * - [center](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-center)
     * - [zoom](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-zoom)
     * - [bearing](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-bearing)
     * - [pitch](https://docs.mapbox.com/mapbox-gl-js/style-spec/#root-pitch)
     *
     * The style default camera is re-evaluated when a new style is loaded.
     *
     * @return The default `camera options` of the current style in use.
     */
    void getStyleDefaultCamera(@NonNull Result<CameraOptions> result);
    /**
     * Returns the map style's transition options. By default, the style parser will attempt
     * to read the style default transition options, if any, fallbacking to an immediate transition
     * otherwise. Transition options can be overriden via `setStyleTransition`, but the options are
     * reset once a new style has been loaded.
     *
     * The style transition is re-evaluated when a new style is loaded.
     *
     * @return The `transition options` of the current style in use.
     */
    void getStyleTransition(@NonNull Result<TransitionOptions> result);
    /**
     * Overrides the map style's transition options with user-provided options.
     *
     * The style transition is re-evaluated when a new style is loaded.
     *
     * @param transitionOptions The `transition options`.
     */
    void setStyleTransition(@NonNull TransitionOptions transitionOptions, @NonNull Result<Void> result);
    /**
     * Adds a new [style layer](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layers).
     *
     * Runtime style layers are valid until they are either removed or a new style is loaded.
     *
     * @param properties A map of style layer properties.
     * @param layerPosition If not empty, the new layer will be positioned according to `layer position` parameters.
     *
     * @return A string describing an error if the operation was not successful, or empty otherwise.
     */
    void addStyleLayer(@NonNull String properties, @Nullable LayerPosition layerPosition, @NonNull Result<Void> result);
    /**
     * Adds a new [style layer](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layers).
     *
     * Whenever a new style is being parsed and currently used style has persistent layers,
     * an engine will try to do following:
     *   - keep the persistent layer at its relative position
     *   - keep the source used by a persistent layer
     *   - keep images added through `addStyleImage` method
     *
     * In cases when a new style has the same layer, source or image resource, style's resources would be
     * used instead and `MapLoadingError` event will be emitted.
     *
     * @param properties A map of style layer properties.
     * @param layerPosition If not empty, the new layer will be positioned according to `layer position` parameters.
     *
     * @return A string describing an error if the operation was not successful, or empty otherwise.
     */
    void addPersistentStyleLayer(@NonNull String properties, @Nullable LayerPosition layerPosition, @NonNull Result<Void> result);
    /**
     * Checks if a style layer is persistent.
     *
     * @param layerId A style layer identifier.
     * @return A string describing an error if the operation was not successful, boolean representing state otherwise.
     */
    void isStyleLayerPersistent(@NonNull String layerId, @NonNull Result<Boolean> result);
    /**
     * Removes an existing style layer.
     *
     * @param layerId An identifier of the style layer to remove.
     *
     * @return A string describing an error if the operation was not successful, or empty otherwise.
     */
    void removeStyleLayer(@NonNull String layerId, @NonNull Result<Void> result);
    /**
     * Moves an existing style layer
     *
     * @param layerId Identifier of the style layer to move.
     * @param layerPosition The layer will be positioned according to the LayerPosition parameters. If an empty LayerPosition
     *                      is provided then the layer is moved to the top of the layerstack.
     *
     * @return A string describing an error if the operation was not successful, or empty otherwise.
     */
    void moveStyleLayer(@NonNull String layerId, @Nullable LayerPosition layerPosition, @NonNull Result<Void> result);
    /**
     * Checks whether a given style layer exists.
     *
     * @param layerId Style layer identifier.
     *
     * @return A `true` value if the given style layer exists, `false` otherwise.
     */
    void styleLayerExists(@NonNull String layerId, @NonNull Result<Boolean> result);
    /**
     * Returns the existing style layers.
     *
     * @return The list containing the information about existing style layer objects.
     */
    void getStyleLayers(@NonNull Result<List<StyleObjectInfo>> result);
    /**
     * Gets the value of style layer property.
     *
     * @param layerId A style layer identifier.
     * @param property The style layer property name.
     * @return The `style property value`.
     */
    void getStyleLayerProperty(@NonNull String layerId, @NonNull String property, @NonNull Result<StylePropertyValue> result);
    /**
     * Sets a value to a style layer property.
     *
     * @param layerId A style layer identifier.
     * @param property The style layer property name.
     * @param value The style layer property value.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void setStyleLayerProperty(@NonNull String layerId, @NonNull String property, @NonNull Object value, @NonNull Result<Void> result);
    /**
     * Gets style layer properties.
     *
     * @return The style layer properties or a string describing an error if the operation was not successful.
     */
    void getStyleLayerProperties(@NonNull String layerId, @NonNull Result<String> result);
    /**
     * Sets style layer properties.
     * This method can be used to perform batch update for a style layer properties. The structure of a
     * provided `properties` value must conform to a format for a corresponding [layer type](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/).
     * Modification of a layer [id](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#id) and/or a [layer type] (https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#type) is not allowed.
     *
     * @param layerId A style layer identifier.
     * @param properties A map of style layer properties.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void setStyleLayerProperties(@NonNull String layerId, @NonNull String properties, @NonNull Result<Void> result);
    /**
     * Adds a new [style source](https://docs.mapbox.com/mapbox-gl-js/style-spec/#sources).
     *
     * @param sourceId An identifier for the style source.
     * @param properties A map of style source properties.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void addStyleSource(@NonNull String sourceId, @NonNull String properties, @NonNull Result<Void> result);
    /**
     * Gets the value of style source property.
     *
     * @param sourceId A style source identifier.
     * @param property The style source property name.
     * @return The value of a `property` in the source with a `sourceId`.
     */
    void getStyleSourceProperty(@NonNull String sourceId, @NonNull String property, @NonNull Result<StylePropertyValue> result);
    /**
     * Sets a value to a style source property.
     * Note: When setting the `data` property of a `geojson` source, this method never returns an error.
     * In case of success, a `map-loaded` event will be propagated. In case of errors, a `map-loading-error` event will be propagated instead.
     *
     *
     * @param sourceId A style source identifier.
     * @param property The style source property name.
     * @param value The style source property value.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void setStyleSourceProperty(@NonNull String sourceId, @NonNull String property, @NonNull Object value, @NonNull Result<Void> result);
    /**
     * Gets style source properties.
     *
     * @param sourceId A style source identifier.
     *
     * @return The style source properties or a string describing an error if the operation was not successful.
     */
    void getStyleSourceProperties(@NonNull String sourceId, @NonNull Result<String> result);
    /**
     * Sets style source properties.
     *
     * This method can be used to perform batch update for a style source properties. The structure of a
     * provided `properties` value must conform to a format for a corresponding [source type](https://docs.mapbox.com/mapbox-gl-js/style-spec/sources/).
     * Modification of a source [type](https://docs.mapbox.com/mapbox-gl-js/style-spec/sources/#type) is not allowed.
     *
     * @param sourceId A style source identifier.
     * @param properties A map of Style source properties.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void setStyleSourceProperties(@NonNull String sourceId, @NonNull String properties, @NonNull Result<Void> result);
    /**
     * Updates the image of an [image style source](https://docs.mapbox.com/mapbox-gl-js/style-spec/#sources-image).
     *
     * @param sourceId A style source identifier.
     * @param image An `image`.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void updateStyleImageSourceImage(@NonNull String sourceId, @NonNull MbxImage image, @NonNull Result<Void> result);
    /**
     * Removes an existing style source.
     *
     * @param sourceId An identifier of the style source to remove.
     */
    void removeStyleSource(@NonNull String sourceId, @NonNull Result<Void> result);
    /**
     * Checks whether a given style source exists.
     *
     * @param sourceId A style source identifier.
     *
     * @return `true` if the given source exists, `false` otherwise.
     */
    void styleSourceExists(@NonNull String sourceId, @NonNull Result<Boolean> result);
    /**
     * Returns the existing style sources.
     *
     * @return The list containing the information about existing style source objects.
     */
    void getStyleSources(@NonNull Result<List<StyleObjectInfo>> result);
    /**
     * Sets the style global [light](https://docs.mapbox.com/mapbox-gl-js/style-spec/#light) properties.
     *
     * @param properties A map of style light properties values, with their names as a key.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void setStyleLight(@NonNull String properties, @NonNull Result<Void> result);
    /**
     * Gets the value of a style light property.
     *
     * @param property The style light property name.
     * @return The style light property value.
     */
    void getStyleLightProperty(@NonNull String property, @NonNull Result<StylePropertyValue> result);
    /**
     * Sets a value to the the style light property.
     *
     * @param property The style light property name.
     * @param value The style light property value.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void setStyleLightProperty(@NonNull String property, @NonNull Object value, @NonNull Result<Void> result);
    /**
     * Sets the style global [terrain](https://docs.mapbox.com/mapbox-gl-js/style-spec/#terrain) properties.
     *
     * @param properties A map of style terrain properties values, with their names as a key.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void setStyleTerrain(@NonNull String properties, @NonNull Result<Void> result);
    /**
     * Gets the value of a style terrain property.
     *
     * @param property The style terrain property name.
     * @return The style terrain property value.
     */
    void getStyleTerrainProperty(@NonNull String property, @NonNull Result<StylePropertyValue> result);
    /**
     * Sets a value to the the style terrain property.
     *
     * @param property The style terrain property name.
     * @param value The style terrain property value.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void setStyleTerrainProperty(@NonNull String property, @NonNull Object value, @NonNull Result<Void> result);
    /**
     * Get an `image` from the style.
     *
     * @param imageId The identifier of the `image`.
     *
     * @return The `image` for the given `imageId`, or empty if no image is associated with the `imageId`.
     */
    void getStyleImage(@NonNull String imageId, @NonNull Result<MbxImage> result);
    /**
     * Adds an image to be used in the style. This API can also be used for updating
     * an image. If the image for a given `imageId` was already added, it gets replaced by the new image.
     *
     * The image can be used in [`icon-image`](https://www.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-icon-image),
     * [`fill-pattern`](https://www.mapbox.com/mapbox-gl-js/style-spec/#paint-fill-fill-pattern),
     * [`line-pattern`](https://www.mapbox.com/mapbox-gl-js/style-spec/#paint-line-line-pattern) and
     * [`text-field`](https://www.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-text-field) properties.
     *
     * @param imageId An identifier of the image.
     * @param scale A scale factor for the image.
     * @param image A pixel data of the image.
     * @param sdf An option to treat whether image is SDF(signed distance field) or not.
     * @param stretchX An array of two-element arrays, consisting of two numbers that represent
     * the from position and the to position of areas that can be stretched horizontally.
     * @param stretchY An array of two-element arrays, consisting of two numbers that represent
     * the from position and the to position of areas that can be stretched vertically.
     * @param content An array of four numbers, with the first two specifying the left, top
     * corner, and the last two specifying the right, bottom corner. If present, and if the
     * icon uses icon-text-fit, the symbol's text will be fit inside the content box.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void addStyleImage(@NonNull String imageId, @NonNull Double scale, @NonNull MbxImage image, @NonNull Boolean sdf, @NonNull List<ImageStretches> stretchX, @NonNull List<ImageStretches> stretchY, @Nullable ImageContent content, @NonNull Result<Void> result);
    /**
     * Removes an image from the style.
     *
     * @param imageId The identifier of the image to remove.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void removeStyleImage(@NonNull String imageId, @NonNull Result<Void> result);
    /**
     * Checks whether an image exists.
     *
     * @param imageId The identifier of the image.
     *
     * @return True if image exists, false otherwise.
     */
    void hasStyleImage(@NonNull String imageId, @NonNull Result<Boolean> result);
    /**
     * Set tile data of a custom geometry.
     *
     * @param sourceId A style source identifier.
     * @param tileId A `canonical tile id` of the tile.
     * @param featureCollection An array with the features to add.
     * Invalidate tile for provided custom geometry source.
     *
     * @param sourceId A style source identifier,.
     * @param tileId A `canonical tile id` of the tile.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void invalidateStyleCustomGeometrySourceTile(@NonNull String sourceId, @NonNull CanonicalTileID tileId, @NonNull Result<Void> result);
    /**
     * Invalidate region for provided custom geometry source.
     *
     * @param sourceId A style source identifier
     * @param bounds A `coordinate bounds` object.
     *
     * @return A string describing an error if the operation was not successful, empty otherwise.
     */
    void invalidateStyleCustomGeometrySourceRegion(@NonNull String sourceId, @NonNull CoordinateBounds bounds, @NonNull Result<Void> result);
    /**
     * Check if the style is completely loaded.
     *
     * Note: The style specified sprite would be marked as loaded even with sprite loading error (An error will be emitted via `MapLoadingError`).
     * Sprite loading error is not fatal and we don't want it to block the map rendering, thus the function will still return `true` if style and sources are fully loaded.
     *
     * @return `true` iff the style JSON contents, the style specified sprite and sources are all loaded, otherwise returns `false`.
     *
     */
    void isStyleLoaded(@NonNull Result<Boolean> result);
    /**
     * Function to get the projection provided by the Style Extension.
     *
     * @return Projection that is currently applied to the map
     */
    void getProjection(@NonNull Result<String> result);
    /**
     * Function to set the projection provided by the Style Extension.
     *
     * @param projection The projection to be set.
     */
    void setProjection(@NonNull String projection, @NonNull Result<Void> result);
    /**
     * Function to localize style labels.
     *
     * @param locale The locale to apply for localization
     * @param layerIds The ids of layers that will localize on, default is null which means will localize all the feasible layers.
     */
    void localizeLabels(@NonNull String locale, @Nullable List<String> layerIds, @NonNull Result<Void> result);

    /** The codec used by StyleManager. */
    static @NonNull MessageCodec<Object> getCodec() {
      return StyleManagerCodec.INSTANCE;
    }
    /**Sets up an instance of `StyleManager` to handle messages through the `binaryMessenger`. */
    static void setup(@NonNull BinaryMessenger binaryMessenger, @Nullable StyleManager api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleURI", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                Result<String> resultCallback =
                    new Result<String>() {
                      public void success(String result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleURI(resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleURI", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String uriArg = (String) args.get(0);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setStyleURI(uriArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleJSON", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                Result<String> resultCallback =
                    new Result<String>() {
                      public void success(String result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleJSON(resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleJSON", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String jsonArg = (String) args.get(0);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setStyleJSON(jsonArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleDefaultCamera", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                Result<CameraOptions> resultCallback =
                    new Result<CameraOptions>() {
                      public void success(CameraOptions result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleDefaultCamera(resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleTransition", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                Result<TransitionOptions> resultCallback =
                    new Result<TransitionOptions>() {
                      public void success(TransitionOptions result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleTransition(resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleTransition", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                TransitionOptions transitionOptionsArg = (TransitionOptions) args.get(0);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setStyleTransition(transitionOptionsArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addStyleLayer", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String propertiesArg = (String) args.get(0);
                LayerPosition layerPositionArg = (LayerPosition) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.addStyleLayer(propertiesArg, layerPositionArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addPersistentStyleLayer", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String propertiesArg = (String) args.get(0);
                LayerPosition layerPositionArg = (LayerPosition) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.addPersistentStyleLayer(propertiesArg, layerPositionArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.isStyleLayerPersistent", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String layerIdArg = (String) args.get(0);
                Result<Boolean> resultCallback =
                    new Result<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.isStyleLayerPersistent(layerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleLayer", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String layerIdArg = (String) args.get(0);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.removeStyleLayer(layerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.moveStyleLayer", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String layerIdArg = (String) args.get(0);
                LayerPosition layerPositionArg = (LayerPosition) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.moveStyleLayer(layerIdArg, layerPositionArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.styleLayerExists", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String layerIdArg = (String) args.get(0);
                Result<Boolean> resultCallback =
                    new Result<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.styleLayerExists(layerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLayers", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                Result<List<StyleObjectInfo>> resultCallback =
                    new Result<List<StyleObjectInfo>>() {
                      public void success(List<StyleObjectInfo> result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleLayers(resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLayerProperty", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String layerIdArg = (String) args.get(0);
                String propertyArg = (String) args.get(1);
                Result<StylePropertyValue> resultCallback =
                    new Result<StylePropertyValue>() {
                      public void success(StylePropertyValue result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleLayerProperty(layerIdArg, propertyArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleLayerProperty", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String layerIdArg = (String) args.get(0);
                String propertyArg = (String) args.get(1);
                Object valueArg = args.get(2);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setStyleLayerProperty(layerIdArg, propertyArg, valueArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLayerProperties", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String layerIdArg = (String) args.get(0);
                Result<String> resultCallback =
                    new Result<String>() {
                      public void success(String result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleLayerProperties(layerIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleLayerProperties", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String layerIdArg = (String) args.get(0);
                String propertiesArg = (String) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setStyleLayerProperties(layerIdArg, propertiesArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addStyleSource", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                String propertiesArg = (String) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.addStyleSource(sourceIdArg, propertiesArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleSourceProperty", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                String propertyArg = (String) args.get(1);
                Result<StylePropertyValue> resultCallback =
                    new Result<StylePropertyValue>() {
                      public void success(StylePropertyValue result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleSourceProperty(sourceIdArg, propertyArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleSourceProperty", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                String propertyArg = (String) args.get(1);
                Object valueArg = args.get(2);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setStyleSourceProperty(sourceIdArg, propertyArg, valueArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleSourceProperties", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                Result<String> resultCallback =
                    new Result<String>() {
                      public void success(String result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleSourceProperties(sourceIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleSourceProperties", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                String propertiesArg = (String) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setStyleSourceProperties(sourceIdArg, propertiesArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.updateStyleImageSourceImage", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                MbxImage imageArg = (MbxImage) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.updateStyleImageSourceImage(sourceIdArg, imageArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleSource", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.removeStyleSource(sourceIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.styleSourceExists", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                Result<Boolean> resultCallback =
                    new Result<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.styleSourceExists(sourceIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleSources", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                Result<List<StyleObjectInfo>> resultCallback =
                    new Result<List<StyleObjectInfo>>() {
                      public void success(List<StyleObjectInfo> result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleSources(resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleLight", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String propertiesArg = (String) args.get(0);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setStyleLight(propertiesArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleLightProperty", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String propertyArg = (String) args.get(0);
                Result<StylePropertyValue> resultCallback =
                    new Result<StylePropertyValue>() {
                      public void success(StylePropertyValue result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleLightProperty(propertyArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleLightProperty", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String propertyArg = (String) args.get(0);
                Object valueArg = args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setStyleLightProperty(propertyArg, valueArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleTerrain", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String propertiesArg = (String) args.get(0);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setStyleTerrain(propertiesArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleTerrainProperty", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String propertyArg = (String) args.get(0);
                Result<StylePropertyValue> resultCallback =
                    new Result<StylePropertyValue>() {
                      public void success(StylePropertyValue result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleTerrainProperty(propertyArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setStyleTerrainProperty", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String propertyArg = (String) args.get(0);
                Object valueArg = args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setStyleTerrainProperty(propertyArg, valueArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getStyleImage", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String imageIdArg = (String) args.get(0);
                Result<MbxImage> resultCallback =
                    new Result<MbxImage>() {
                      public void success(MbxImage result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getStyleImage(imageIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.addStyleImage", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String imageIdArg = (String) args.get(0);
                Double scaleArg = (Double) args.get(1);
                MbxImage imageArg = (MbxImage) args.get(2);
                Boolean sdfArg = (Boolean) args.get(3);
                List<ImageStretches> stretchXArg = (List<ImageStretches>) args.get(4);
                List<ImageStretches> stretchYArg = (List<ImageStretches>) args.get(5);
                ImageContent contentArg = (ImageContent) args.get(6);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.addStyleImage(imageIdArg, scaleArg, imageArg, sdfArg, stretchXArg, stretchYArg, contentArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.removeStyleImage", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String imageIdArg = (String) args.get(0);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.removeStyleImage(imageIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.hasStyleImage", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String imageIdArg = (String) args.get(0);
                Result<Boolean> resultCallback =
                    new Result<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.hasStyleImage(imageIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.invalidateStyleCustomGeometrySourceTile", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                CanonicalTileID tileIdArg = (CanonicalTileID) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.invalidateStyleCustomGeometrySourceTile(sourceIdArg, tileIdArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.invalidateStyleCustomGeometrySourceRegion", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String sourceIdArg = (String) args.get(0);
                CoordinateBounds boundsArg = (CoordinateBounds) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.invalidateStyleCustomGeometrySourceRegion(sourceIdArg, boundsArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.isStyleLoaded", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                Result<Boolean> resultCallback =
                    new Result<Boolean>() {
                      public void success(Boolean result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.isStyleLoaded(resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.getProjection", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                Result<String> resultCallback =
                    new Result<String>() {
                      public void success(String result) {
                        wrapped.add(0, result);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.getProjection(resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.setProjection", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String projectionArg = (String) args.get(0);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.setProjection(projectionArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.StyleManager.localizeLabels", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                String localeArg = (String) args.get(0);
                List<String> layerIdsArg = (List<String>) args.get(1);
                Result<Void> resultCallback =
                    new Result<Void>() {
                      public void success(Void result) {
                        wrapped.add(0, null);
                        reply.reply(wrapped);
                      }

                      public void error(Throwable error) {
                        ArrayList<Object> wrappedError = wrapError(error);
                        reply.reply(wrappedError);
                      }
                    };

                api.localizeLabels(localeArg, layerIdsArg, resultCallback);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }
  /**
   * Allows to cancel the associated asynchronous operation
   *
   * The the associated asynchronous operation is not automatically canceled if this
   * object goes out of scope.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface Cancelable {
    /**
     * Cancels the associated asynchronous operation
     *
     * If the associated asynchronous operation has already finished, this call is ignored.
     */
    void cancel();

    /** The codec used by Cancelable. */
    static @NonNull MessageCodec<Object> getCodec() {
      return new StandardMessageCodec();
    }
    /**Sets up an instance of `Cancelable` to handle messages through the `binaryMessenger`. */
    static void setup(@NonNull BinaryMessenger binaryMessenger, @Nullable Cancelable api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.Cancelable.cancel", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  api.cancel();
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }
  /**
   * Instance that allows connecting or disconnecting the Mapbox stack to the network.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface OfflineSwitch {
    /**
     * Connects or disconnects the Mapbox stack. If set to false, current and new HTTP requests will fail
     * with HttpRequestErrorType#ConnectionError.
     *
     * @param connected Set false to disconnect the Mapbox stack
     */
    void setMapboxStackConnected(@NonNull Boolean connected);
    /**
     * Provides information if the Mapbox stack is connected or disconnected via OfflineSwitch.
     *
     * @return True if the Mapbox stack is disconnected via setMapboxStackConnected(), false otherwise.
     */
    @NonNull 
    Boolean isMapboxStackConnected();
    /**
     * Releases the OfflineSwitch singleton instance.
     *
     * Users can call this method if they want to do manual cleanup of the resources allocated by Mapbox services.
     * If the user calls getInstance() after reset, a new instance of the OfflineSwitch singleton will be allocated.
     */
    void reset();

    /** The codec used by OfflineSwitch. */
    static @NonNull MessageCodec<Object> getCodec() {
      return new StandardMessageCodec();
    }
    /**Sets up an instance of `OfflineSwitch` to handle messages through the `binaryMessenger`. */
    static void setup(@NonNull BinaryMessenger binaryMessenger, @Nullable OfflineSwitch api) {
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineSwitch.setMapboxStackConnected", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                ArrayList<Object> args = (ArrayList<Object>) message;
                Boolean connectedArg = (Boolean) args.get(0);
                try {
                  api.setMapboxStackConnected(connectedArg);
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineSwitch.isMapboxStackConnected", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  Boolean output = api.isMapboxStackConnected();
                  wrapped.add(0, output);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
      {
        BasicMessageChannel<Object> channel =
            new BasicMessageChannel<>(
                binaryMessenger, "dev.flutter.pigeon.mapbox_maps_flutter.OfflineSwitch.reset", getCodec());
        if (api != null) {
          channel.setMessageHandler(
              (message, reply) -> {
                ArrayList<Object> wrapped = new ArrayList<Object>();
                try {
                  api.reset();
                  wrapped.add(0, null);
                }
 catch (Throwable exception) {
                  ArrayList<Object> wrappedError = wrapError(exception);
                  wrapped = wrappedError;
                }
                reply.reply(wrapped);
              });
        } else {
          channel.setMessageHandler(null);
        }
      }
    }
  }
  /**
   * A bundle that encapsulates tilesets creation for the tile store implementation.
   *
   * Tileset descriptors describe the type of data that should be part of the Offline Region, like the routing profile for Navigation and the Tilesets of the Map style.
   *
   * Generated interface from Pigeon that represents a handler of messages from Flutter.
   */
  public interface TilesetDescriptor {

    /** The codec used by TilesetDescriptor. */
    static @NonNull MessageCodec<Object> getCodec() {
      return new StandardMessageCodec();
    }
    /**Sets up an instance of `TilesetDescriptor` to handle messages through the `binaryMessenger`. */
    static void setup(@NonNull BinaryMessenger binaryMessenger, @Nullable TilesetDescriptor api) {
    }
  }
}
